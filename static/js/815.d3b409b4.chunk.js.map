{"version":3,"file":"static/js/815.d3b409b4.chunk.js","mappings":"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","sources":["components/Freestyle/exercises/grammar/FillConjugationTable.js"],"sourcesContent":["import React, { useState, useEffect, useMemo } from 'react';\nimport { useI18n } from '../../../../i18n/I18nContext';\nimport { normalizeString } from '../../../../utils/stringUtils';\nimport useLatinization from '../../../../hooks/useLatinization';\n\n// Determine common pronouns, can be expanded or made language-specific\nconst getPronounsForTable = (language, verbTenses) => {\n    // Attempt to extract pronouns from the first available tense and its forms\n    if (verbTenses && Object.keys(verbTenses).length > 0) {\n        const firstTenseKey = Object.keys(verbTenses)[0];\n        const firstTense = verbTenses[firstTenseKey];\n        if (firstTense && firstTense.forms && Object.keys(firstTense.forms).length > 0) {\n            return Object.keys(firstTense.forms);\n        }\n    }\n    // Fallback pronouns if extraction fails (can be language-specific)\n    // This is a simplified list; real applications might need more robust pronoun sets per language.\n    if (language === 'COSYfrench') return ['je', 'tu', 'il/elle/on', 'nous', 'vous', 'ils/elles'];\n    if (language === 'COSYespañol') return ['yo', 'tú', 'él/ella/usted', 'nosotros', 'vosotros', 'ellos/ellas/ustedes'];\n    if (language === 'COSYenglish') return ['i', 'you', 'he/she/it', 'we', 'they'];\n    return ['pronoun1', 'pronoun2', 'pronoun3', 'pronoun4', 'pronoun5', 'pronoun6']; // Generic fallback\n};\n\n\nconst FillConjugationTable = ({ verb, language, tensesToShow, onCheckAnswers, onSetFeedback, isRevealedExternally, onSetAllCorrect }) => {\n  const { t } = useI18n();\n  const getLatinizedText = useLatinization();\n\n  const [userInputs, setUserInputs] = useState({}); // Store user inputs as { 'pronoun_tense': 'value' }\n  const [solution, setSolution] = useState({}); // Store correct answers for blanked cells\n  const [prefilledCells, setPrefilledCells] = useState({}); // Store cells that are pre-filled\n  const [cellStatus, setCellStatus] = useState({}); // Store status of each cell: 'correct', 'incorrect', 'neutral'\n\n  const pronouns = useMemo(() => getPronounsForTable(language, verb.tenses), [language, verb.tenses]);\n  const activeTenses = useMemo(() => {\n    return tensesToShow.filter(tenseKey => verb.tenses[tenseKey.toLowerCase()]);\n  }, [tensesToShow, verb.tenses]);\n\n\n  useEffect(() => {\n    const newSolution = {};\n    const newPrefilled = {};\n    const initialUserInputs = {};\n    const initialCellStatus = {};\n\n    // Randomly decide which cells to make blank (e.g., 50% chance)\n    // Ensure at least one blank if possible, and not too many blanks.\n    let blankCount = 0;\n    const totalPossibleCells = pronouns.length * activeTenses.length;\n    const targetBlankCells = Math.max(1, Math.min(pronouns.length * 2, Math.floor(totalPossibleCells * 0.5))); // Aim for about 50% blanks, min 1, max 2 per pronoun avg.\n\n    const cells = [];\n    pronouns.forEach(pronoun => {\n        activeTenses.forEach(tenseKey => {\n            cells.push({pronoun, tenseKey});\n        });\n    });\n    // Shuffle cells to randomize blank selection\n    for (let i = cells.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [cells[i], cells[j]] = [cells[j], cells[i]];\n    }\n\n    cells.forEach(({pronoun, tenseKey}) => {\n        const cellKey = `${pronoun}_${tenseKey}`;\n        const tenseData = verb.tenses[tenseKey.toLowerCase()];\n        const correctAnswer = tenseData && tenseData.forms[pronoun] ? tenseData.forms[pronoun] : '';\n\n        if (correctAnswer) { // Only consider cells that should have an answer\n            if (blankCount < targetBlankCells && Math.random() < 0.65) { // Prioritize making some cells blank\n                newSolution[cellKey] = correctAnswer;\n                initialUserInputs[cellKey] = '';\n                blankCount++;\n            } else {\n                newPrefilled[cellKey] = correctAnswer;\n            }\n        }\n        initialCellStatus[cellKey] = 'neutral';\n    });\n\n    // If no blanks were made (e.g. very small table), force one if possible\n    if (blankCount === 0 && totalPossibleCells > 0) {\n        for (const {pronoun, tenseKey} of cells) {\n             const cellKey = `${pronoun}_${tenseKey}`;\n             const tenseData = verb.tenses[tenseKey.toLowerCase()];\n             const correctAnswer = tenseData && tenseData.forms[pronoun] ? tenseData.forms[pronoun] : '';\n             if (correctAnswer) {\n                newSolution[cellKey] = correctAnswer;\n                initialUserInputs[cellKey] = '';\n                delete newPrefilled[cellKey]; // Ensure it's not prefilled\n                initialCellStatus[cellKey] = 'neutral';\n                break;\n             }\n        }\n    }\n\n    setSolution(newSolution);\n    setPrefilledCells(newPrefilled);\n    setUserInputs(initialUserInputs);\n    setCellStatus(initialCellStatus);\n    if (onSetFeedback) onSetFeedback({ message: '', type: '' });\n\n  }, [verb, language, pronouns, activeTenses, onSetFeedback]);\n\n  useEffect(() => {\n      if (isRevealedExternally) {\n          const revealedInputs = {};\n          const newCellStatus = { ...cellStatus }; // Create a new object for cellStatus\n          Object.keys(solution).forEach(cellKey => {\n              revealedInputs[cellKey] = solution[cellKey].split('/')[0]; // Show first answer if multiple\n              newCellStatus[cellKey] = 'revealed';\n          });\n          setUserInputs(revealedInputs);\n          setCellStatus(newCellStatus);\n      }\n  }, [isRevealedExternally, solution, cellStatus]); // Removed cellStatus from deps as it's being set, include if logic depends on previous cellStatus\n\n\n  const handleInputChange = (pronoun, tenseKey, value) => {\n    const cellKey = `${pronoun}_${tenseKey}`;\n    setUserInputs(prev => ({ ...prev, [cellKey]: value }));\n    setCellStatus(prev => ({ ...prev, [cellKey]: 'neutral' })); // Reset status on change\n    if (onSetFeedback) onSetFeedback({ message: '', type: '' });\n  };\n\n  const checkCellAnswers = React.useCallback(() => {\n    let allCorrectInternal = true;\n    let correctCount = 0;\n    const newCellStatus = { ...cellStatus };\n\n    Object.keys(solution).forEach(cellKey => {\n      const userAns = normalizeString(userInputs[cellKey] || '');\n      const correctAnses = solution[cellKey].split('/').map(s => normalizeString(s));\n\n      if (correctAnses.includes(userAns) && userAns !== '') {\n        newCellStatus[cellKey] = 'correct';\n        correctCount++;\n      } else if (userAns === '') {\n        newCellStatus[cellKey] = 'neutral'; // Keep neutral if empty\n        allCorrectInternal = false; // Consider empty as not fully correct for overall status\n      } else {\n        newCellStatus[cellKey] = 'incorrect';\n        allCorrectInternal = false;\n      }\n    });\n    setCellStatus(newCellStatus);\n\n    if (allCorrectInternal && Object.keys(solution).length > 0 && correctCount === Object.keys(solution).length) {\n      if (onSetFeedback) onSetFeedback({ message: t('feedback.allCorrectTable', 'All filled answers are correct!'), type: 'success' });\n      if (onSetAllCorrect) onSetAllCorrect(true);\n    } else if (!allCorrectInternal && Object.keys(solution).length > 0) {\n      if (onSetFeedback) onSetFeedback({ message: t('feedback.someIncorrectTable', 'Some answers are incorrect. Please review.'), type: 'incorrect' });\n      if (onSetAllCorrect) onSetAllCorrect(false);\n    } else {\n      if (onSetFeedback) onSetFeedback({ message: '', type: '' }); // No input yet or no blanks\n    }\n    return allCorrectInternal && correctCount === Object.keys(solution).length;\n  }, [userInputs, solution, cellStatus, onSetFeedback, t, onSetAllCorrect]);\n\n  // Expose checkCellAnswers via the onCheckAnswers prop from parent\n  useEffect(() => {\n    if (onCheckAnswers) {\n      onCheckAnswers.current = checkCellAnswers;\n    }\n  }, [onCheckAnswers, checkCellAnswers]);\n\n\n  if (!verb || !verb.tenses || activeTenses.length === 0) {\n    return <p>{t('loading.noTensesForVerb', 'No tenses available for this verb or tensesToShow not configured.')}</p>;\n  }\n  const latinizedInfinitive = getLatinizedText(verb.infinitive, language);\n\n  return (\n    <div style={{ margin: '20px 0' }}>\n      <h4>{t('labels.conjugateVerb', `Conjugate the verb: \"${latinizedInfinitive}\"` , {verbName: latinizedInfinitive} )}</h4>\n      <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '10px' }}>\n        <thead>\n          <tr>\n            <th style={tableCellStyle(true)}>{t('labels.pronoun', 'Pronoun')}</th>\n            {activeTenses.map(tenseKey => (\n              <th key={tenseKey} style={tableCellStyle(true)}>{getLatinizedText(tenseKey.replace(/_/g, ' '), language)}</th>\n            ))}\n          </tr>\n        </thead>\n        <tbody>\n          {pronouns.map(pronoun => (\n            <tr key={pronoun}>\n              <td style={tableCellStyle()}>{getLatinizedText(pronoun, language)}</td>\n              {activeTenses.map(tenseKey => {\n                const cellKey = `${pronoun}_${tenseKey}`;\n                const isBlank = cellKey in solution;\n                const prefilledValue = prefilledCells[cellKey];\n                const cellCurrentStatus = cellStatus[cellKey] || 'neutral';\n\n                return (\n                  <td key={tenseKey} style={tableCellStyle(false, cellCurrentStatus)}>\n                    {isBlank ? (\n                      <input\n                        type=\"text\"\n                        value={userInputs[cellKey] || ''}\n                        onChange={e => handleInputChange(pronoun, tenseKey, e.target.value)}\n                        disabled={isRevealedExternally || cellCurrentStatus === 'correct'}\n                        style={{ width: '95%', padding: '8px', fontSize: '0.95rem', boxSizing: 'border-box', border: '1px solid #ccc', borderRadius: '4px', textAlign: 'center' }}\n                        aria-label={t('ariaLabels.verbFormFor', `Verb form for {pronoun} in {tense}`, {pronoun: getLatinizedText(pronoun, language), tense: getLatinizedText(tenseKey, language)})}\n                      />\n                    ) : (\n                      <span style={{ fontSize: '0.95rem' }}>{getLatinizedText(prefilledValue, language)}</span>\n                    )}\n                  </td>\n                );\n              })}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nconst tableCellStyle = (isHeader = false, status = 'neutral') => {\n  let style = {\n    border: '1px solid #ddd',\n    padding: '8px',\n    textAlign: 'center',\n    minWidth: '100px',\n    backgroundColor: isHeader ? '#f2f2f2' : '#fff',\n    fontWeight: isHeader ? 'bold' : 'normal',\n  };\n  if (!isHeader) {\n    if (status === 'correct') style.backgroundColor = '#d4edda'; // Greenish for correct\n    else if (status === 'incorrect') style.backgroundColor = '#f8d7da'; // Reddish for incorrect\n    else if (status === 'revealed') style.backgroundColor = '#cfe2ff'; // Bluish for revealed\n  }\n  return style;\n};\n\nexport default FillConjugationTable;\n"],"names":["tableCellStyle","isHeader","arguments","length","undefined","status","style","border","padding","textAlign","minWidth","backgroundColor","fontWeight","_ref","verb","language","tensesToShow","onCheckAnswers","onSetFeedback","isRevealedExternally","onSetAllCorrect","t","useI18n","getLatinizedText","useLatinization","userInputs","setUserInputs","useState","solution","setSolution","prefilledCells","setPrefilledCells","cellStatus","setCellStatus","pronouns","useMemo","getPronounsForTable","verbTenses","Object","keys","firstTense","forms","tenses","activeTenses","filter","tenseKey","toLowerCase","useEffect","newSolution","newPrefilled","initialUserInputs","initialCellStatus","blankCount","totalPossibleCells","targetBlankCells","Math","max","min","floor","cells","forEach","pronoun","push","i","j","random","_ref2","cellKey","tenseData","correctAnswer","message","type","revealedInputs","newCellStatus","split","checkCellAnswers","React","allCorrectInternal","correctCount","userAns","normalizeString","map","s","includes","current","_jsx","children","latinizedInfinitive","infinitive","_jsxs","margin","verbName","width","borderCollapse","marginTop","replace","isBlank","prefilledValue","cellCurrentStatus","value","onChange","e","handleInputChange","prev","target","disabled","fontSize","boxSizing","borderRadius","tense"],"sourceRoot":""}