{"ast":null,"code":"// frontend/src/utils/speechUtils.js\n\n/**\r\n * Maps COSYlanguage identifiers to BCP 47 language codes for Web Speech API.\r\n * @param {string} cosyLanguage - The COSYlanguage identifier (e.g., \"COSYenglish\").\r\n * @returns {string} The BCP 47 language code (e.g., \"en-US\").\r\n */\nexport function mapLanguageToSpeechCode(cosyLanguage) {\n  let speechCode;\n  let isFallback = false;\n  // Ensure cosyLanguage is a string before calling toLowerCase or other string methods\n  const langStr = String(cosyLanguage || '');\n  switch (langStr) {\n    case 'COSYenglish':\n      speechCode = 'en-US';\n      break;\n    case 'COSYfrançais':\n      speechCode = 'fr-FR';\n      break;\n    case 'COSYespañol':\n      speechCode = 'es-ES';\n      break;\n    case 'COSYitaliano':\n      speechCode = 'it-IT';\n      break;\n    case 'COSYdeutsch':\n      speechCode = 'de-DE';\n      break;\n    case 'COSYportuguês':\n      speechCode = 'pt-PT';\n      break;\n    case 'ΚΟΖΥελληνικά':\n      speechCode = 'el-GR';\n      break;\n    case 'ТАКОЙрусский':\n      speechCode = 'ru-RU';\n      break;\n    case 'ԾՈՍՅհայկական':\n      speechCode = 'hy-AM';\n      break;\n    case 'COSYbrezhoneg':\n      speechCode = 'fr-FR';\n      isFallback = true;\n      break;\n    // Breton uses French as a fallback\n    case 'COSYtatarça':\n      speechCode = 'ru-RU';\n      isFallback = true;\n      break;\n    // Tatar uses Russian as a fallback\n    case 'COSYbashkort':\n      speechCode = 'ru-RU';\n      isFallback = true;\n      break;\n    // Bashkir uses Russian as a fallback\n    default:\n      console.warn(`SpeechUtils: Unknown COSYlanguage \"${langStr}\". Defaulting to en-US.`);\n      speechCode = 'en-US';\n      isFallback = true;\n      break;\n  }\n  if (isFallback && langStr !== '') {\n    // Avoid logging fallback for empty input\n    console.warn(`SpeechUtils: No direct speech synthesis voice for ${cosyLanguage}. Using fallback ${speechCode}.`);\n  }\n  return speechCode;\n}\n\n/**\r\n * Pronounces a given text using the Web Speech API.\r\n * @param {string} text - The text to pronounce.\r\n * @param {string} cosyLanguage - The COSYlanguage identifier for the text's language.\r\n * @returns {Promise<void>} A promise that resolves when speaking starts or rejects on error/no support.\r\n */\nexport const pronounceText = (text, cosyLanguage) => {\n  return new Promise((resolve, reject) => {\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      console.error('SpeechUtils: Speech Synthesis not supported by this browser or not in a browser environment.');\n      reject(new Error('Speech Synthesis not supported'));\n      return;\n    }\n    if (!text || String(text).trim() === '') {\n      console.warn('PronounceText: No text provided.');\n      // Resolve an empty promise as there's nothing to speak.\n      // Or reject, depending on desired behavior for empty text. For now, resolving.\n      resolve();\n      return;\n    }\n    const speechLang = mapLanguageToSpeechCode(cosyLanguage);\n    const utterance = new SpeechSynthesisUtterance(String(text).trim());\n    utterance.lang = speechLang;\n\n    // Cancel any ongoing speech before speaking a new one\n    window.speechSynthesis.cancel();\n    utterance.onstart = () => {\n      console.log(`SpeechUtils: Speaking \"${text}\" in ${cosyLanguage} (mapped to ${speechLang})`);\n      resolve();\n    };\n    utterance.onerror = event => {\n      console.error('SpeechUtils: SpeechSynthesisUtterance.onerror - Error speaking:', event.error, 'for text:', text, 'lang:', speechLang);\n      reject(event.error instanceof Error ? event.error : new Error(String(event.error || 'Unknown speech error')));\n    };\n\n    // Some browsers might not fire onstart immediately or reliably.\n    // Fallback: resolve after a short delay if onstart doesn't fire,\n    // but this is less ideal than relying on the event.\n    // For simplicity, we'll rely on onstart and onerror.\n\n    window.speechSynthesis.speak(utterance);\n  });\n};\n\n/**\r\n * Attempts to unlock audio playback in the browser.\r\n * Call this after a user interaction if speech synthesis isn't working.\r\n */\nexport const unlockAudioPlayback = () => {\n  if (typeof window !== 'undefined' && typeof Audio !== 'undefined') {\n    try {\n      const silentAudio = new Audio(\"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA\");\n      silentAudio.volume = 0;\n      const playPromise = silentAudio.play();\n      if (playPromise !== undefined) {\n        playPromise.then(_ => {\n          console.log(\"SpeechUtils: Audio playback likely unlocked.\");\n        }).catch(error => {\n          console.warn(\"SpeechUtils: Audio unlock failed (this is common, user interaction might be needed for audio):\", error);\n        });\n      }\n    } catch (e) {\n      console.error(\"SpeechUtils: Error trying to unlock audio:\", e);\n    }\n  }\n};\n\n// Speech Recognition (STT) logic will be handled separately, likely in a custom hook.\nconsole.log('[SpeechUtils] Service loaded with TTS and language mapping.');","map":{"version":3,"names":["mapLanguageToSpeechCode","cosyLanguage","speechCode","isFallback","langStr","String","console","warn","pronounceText","text","Promise","resolve","reject","window","speechSynthesis","error","Error","trim","speechLang","utterance","SpeechSynthesisUtterance","lang","cancel","onstart","log","onerror","event","speak","unlockAudioPlayback","Audio","silentAudio","volume","playPromise","play","undefined","then","_","catch","e"],"sources":["/workspaces/COSYlanguagesproject/src/utils/speechUtils.js"],"sourcesContent":["// frontend/src/utils/speechUtils.js\r\n\r\n/**\r\n * Maps COSYlanguage identifiers to BCP 47 language codes for Web Speech API.\r\n * @param {string} cosyLanguage - The COSYlanguage identifier (e.g., \"COSYenglish\").\r\n * @returns {string} The BCP 47 language code (e.g., \"en-US\").\r\n */\r\nexport function mapLanguageToSpeechCode(cosyLanguage) {\r\n  let speechCode;\r\n  let isFallback = false;\r\n  // Ensure cosyLanguage is a string before calling toLowerCase or other string methods\r\n  const langStr = String(cosyLanguage || '');\r\n\r\n  switch(langStr) {\r\n    case 'COSYenglish': speechCode = 'en-US'; break;\r\n    case 'COSYfrançais': speechCode = 'fr-FR'; break;\r\n    case 'COSYespañol': speechCode = 'es-ES'; break;\r\n    case 'COSYitaliano': speechCode = 'it-IT'; break;\r\n    case 'COSYdeutsch': speechCode = 'de-DE'; break;\r\n    case 'COSYportuguês': speechCode = 'pt-PT'; break;\r\n    case 'ΚΟΖΥελληνικά': speechCode = 'el-GR'; break;\r\n    case 'ТАКОЙрусский': speechCode = 'ru-RU'; break;\r\n    case 'ԾՈՍՅհայկական': speechCode = 'hy-AM'; break;\r\n    case 'COSYbrezhoneg': speechCode = 'fr-FR'; isFallback = true; break; // Breton uses French as a fallback\r\n    case 'COSYtatarça': speechCode = 'ru-RU'; isFallback = true; break;   // Tatar uses Russian as a fallback\r\n    case 'COSYbashkort': speechCode = 'ru-RU'; isFallback = true; break; // Bashkir uses Russian as a fallback\r\n    default: \r\n      console.warn(`SpeechUtils: Unknown COSYlanguage \"${langStr}\". Defaulting to en-US.`);\r\n      speechCode = 'en-US'; \r\n      isFallback = true; \r\n      break;\r\n  }\r\n  if (isFallback && langStr !== '') { // Avoid logging fallback for empty input\r\n    console.warn(`SpeechUtils: No direct speech synthesis voice for ${cosyLanguage}. Using fallback ${speechCode}.`);\r\n  }\r\n  return speechCode;\r\n}\r\n\r\n/**\r\n * Pronounces a given text using the Web Speech API.\r\n * @param {string} text - The text to pronounce.\r\n * @param {string} cosyLanguage - The COSYlanguage identifier for the text's language.\r\n * @returns {Promise<void>} A promise that resolves when speaking starts or rejects on error/no support.\r\n */\r\nexport const pronounceText = (text, cosyLanguage) => {\r\n  return new Promise((resolve, reject) => {\r\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\r\n      console.error('SpeechUtils: Speech Synthesis not supported by this browser or not in a browser environment.');\r\n      reject(new Error('Speech Synthesis not supported'));\r\n      return;\r\n    }\r\n\r\n    if (!text || String(text).trim() === '') {\r\n      console.warn('PronounceText: No text provided.');\r\n      // Resolve an empty promise as there's nothing to speak.\r\n      // Or reject, depending on desired behavior for empty text. For now, resolving.\r\n      resolve(); \r\n      return;\r\n    }\r\n\r\n    const speechLang = mapLanguageToSpeechCode(cosyLanguage);\r\n    const utterance = new SpeechSynthesisUtterance(String(text).trim());\r\n    utterance.lang = speechLang;\r\n    \r\n    // Cancel any ongoing speech before speaking a new one\r\n    window.speechSynthesis.cancel(); \r\n\r\n    utterance.onstart = () => {\r\n      console.log(`SpeechUtils: Speaking \"${text}\" in ${cosyLanguage} (mapped to ${speechLang})`);\r\n      resolve();\r\n    };\r\n\r\n    utterance.onerror = (event) => {\r\n      console.error('SpeechUtils: SpeechSynthesisUtterance.onerror - Error speaking:', event.error, 'for text:', text, 'lang:', speechLang);\r\n      reject(event.error instanceof Error ? event.error : new Error(String(event.error || 'Unknown speech error')));\r\n    };\r\n    \r\n    // Some browsers might not fire onstart immediately or reliably.\r\n    // Fallback: resolve after a short delay if onstart doesn't fire,\r\n    // but this is less ideal than relying on the event.\r\n    // For simplicity, we'll rely on onstart and onerror.\r\n\r\n    window.speechSynthesis.speak(utterance);\r\n  });\r\n};\r\n\r\n/**\r\n * Attempts to unlock audio playback in the browser.\r\n * Call this after a user interaction if speech synthesis isn't working.\r\n */\r\nexport const unlockAudioPlayback = () => {\r\n  if (typeof window !== 'undefined' && typeof Audio !== 'undefined') {\r\n    try {\r\n      const silentAudio = new Audio(\"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA\");\r\n      silentAudio.volume = 0;\r\n      const playPromise = silentAudio.play();\r\n\r\n      if (playPromise !== undefined) {\r\n        playPromise.then(_ => {\r\n          console.log(\"SpeechUtils: Audio playback likely unlocked.\");\r\n        }).catch(error => {\r\n          console.warn(\"SpeechUtils: Audio unlock failed (this is common, user interaction might be needed for audio):\", error);\r\n        });\r\n      }\r\n    } catch (e) {\r\n      console.error(\"SpeechUtils: Error trying to unlock audio:\", e);\r\n    }\r\n  }\r\n};\r\n\r\n// Speech Recognition (STT) logic will be handled separately, likely in a custom hook.\r\nconsole.log('[SpeechUtils] Service loaded with TTS and language mapping.');\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}