{"ast":null,"code":"// frontend/src/utils/exerciseDataService.js\n\n/**\r\n * Generic function to fetch JSON data from a given file path.\r\n * Assumes paths are relative to the public folder or served from the root.\r\n * @param {string} filePath - The path to the JSON file.\r\n * @returns {Promise<{data: any, error: string|null, errorType: string|null}>}\r\n */\nasync function fetchJsonData(filePath) {\n  try {\n    // In a React app, paths for static assets in `public` are usually relative to the root.\n    // If your `data` folder is in `public`, paths would be like `/data/vocabulary/words/english.json`.\n    // If served via a specific route by a dev server or backend, adjust accordingly.\n    const response = await fetch(filePath);\n    if (response.ok) {\n      try {\n        const data = await response.json();\n        return {\n          data,\n          error: null,\n          errorType: null\n        };\n      } catch (jsonError) {\n        console.error(`Error parsing JSON from ${filePath}:`, jsonError);\n        return {\n          data: null,\n          error: 'Invalid JSON format',\n          errorType: 'jsonError'\n        };\n      }\n    } else {\n      const errorContext = `HTTP error ${response.status} while fetching ${filePath}`;\n      console.error(errorContext);\n      if (response.status === 404) {\n        return {\n          data: null,\n          error: `File not found: ${filePath}`,\n          errorType: 'fileNotFound'\n        };\n      }\n      return {\n        data: null,\n        error: `Failed to load data: ${errorContext}`,\n        errorType: 'httpError'\n      };\n    }\n  } catch (networkError) {\n    console.error(`Network error or other exception while loading data from ${filePath}:`, networkError);\n    return {\n      data: null,\n      error: `Network error: ${networkError.message}`,\n      errorType: 'networkError'\n    };\n  }\n}\nconst langFileMap = {\n  'COSYenglish': 'english',\n  'COSYfrançais': 'french',\n  // This maps to 'french'\n  'COSYespañol': 'spanish',\n  'COSYitaliano': 'italian',\n  'COSYdeutsch': 'german',\n  'COSYportuguês': 'portuguese',\n  'ΚΟΖΥελληνικά': 'greek',\n  'ТАКОЙрусский': 'russian',\n  'ԾՈՍՅհայկական': 'armenian',\n  'COSYbrezhoneg': 'breton',\n  'COSYtatarça': 'tatar',\n  'COSYbashkort': 'bashkir'\n};\nfunction getLanguageFileKey(languageIdentifier) {\n  return langFileMap[languageIdentifier] || 'english'; // Default to English\n}\n\n/**\r\n * Processes fetched data based on selected day(s).\r\n * @param {object} allData - The entire data object fetched from JSON.\r\n * @param {string|string[]} days - The selected day or array of days.\r\n * @returns {Array|Object} - The filtered data for the selected day(s).\r\n */\nfunction filterDataByDays(allData, days) {\n  if (!allData) return Array.isArray(days) ? [] : {}; // Return empty array for multiple days, object for single/opposites\n\n  let dayData;\n  if (Array.isArray(days)) {\n    dayData = [];\n    days.forEach(d => {\n      if (allData[d]) dayData = dayData.concat(allData[d]);\n    });\n  } else {\n    // Single day or data structure not an array (like opposites)\n    if (typeof days === 'string' || typeof days === 'number') {\n      // Ensure 'days' is a valid key\n      dayData = allData[days] || (typeof allData === 'object' && !Array.isArray(allData) ? {} : []);\n    } else {\n      // If days is not a string/number (e.g. undefined, null), return all data or empty if not applicable\n      dayData = allData; // This might be the case for data not structured by day, like images.json root\n    }\n  }\n  return dayData;\n}\nexport async function loadVocabularyData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  const filePath = `/data/vocabulary/words/${langKey}.json`;\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  if (error) return {\n    data: [],\n    error,\n    errorType\n  }; // Ensure consistent error structure\n  return {\n    data: filterDataByDays(data, days),\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadImageData(languageIdentifier, days) {\n  const filePath = `/data/vocabulary/images/images.json`; // Single file for all image metadata\n  const {\n    data: allImageData,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  if (error) return {\n    data: [],\n    error,\n    errorType\n  };\n  const imageDataForDays = filterDataByDays(allImageData, days);\n\n  // Filter images that have a translation for the current language\n  const filteredImages = Array.isArray(imageDataForDays) ? imageDataForDays.filter(img => img.translations && img.translations[languageIdentifier]) : []; // If not an array (e.g. error or unexpected structure), return empty\n\n  return {\n    data: filteredImages,\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadOppositesData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  const filePath = `/data/vocabulary/opposites/${langKey}.json`;\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  if (error) return {\n    data: {},\n    error,\n    errorType\n  };\n  // Opposites might be an object where keys are days, and values are objects of word-opposite pairs.\n  // Or, if days is a single day, it directly returns the object for that day.\n  // filterDataByDays should handle this.\n  const dayData = filterDataByDays(data, days);\n\n  // If 'days' was an array, we need to merge the objects from each day.\n  if (Array.isArray(days) && Array.isArray(dayData)) {\n    const mergedOpposites = dayData.reduce((acc, dayObj) => ({\n      ...acc,\n      ...dayObj\n    }), {});\n    return {\n      data: mergedOpposites,\n      error: null,\n      errorType: null\n    };\n  }\n  return {\n    data: dayData,\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadGenderGrammarData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  const filePath = `/data/grammar/gender/grammar_gender_${langKey}.json`;\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  if (error) return {\n    data: [],\n    error,\n    errorType\n  };\n  return {\n    data: filterDataByDays(data, days),\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadPossessivesData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  // Ensure langKey for filename is 'francais' if languageIdentifier is 'COSYfrançais' (which maps to 'french')\n  const filenameLangKey = langKey === 'french' ? 'francais' : langKey;\n  const filePath = `/data/grammar/possessives/${filenameLangKey}.json`;\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  // Possessives data is an object where keys are day numbers and values are arrays of exercise items.\n  // If error, return empty object as per conventions for object-based data.\n  if (error) return {\n    data: {},\n    error,\n    errorType\n  };\n  return {\n    data: filterDataByDays(data, days),\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadVerbGrammarData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  const filePath = `/data/grammar/verbs/grammar_verbs_${langKey}.json`;\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  // Verb data often needs more processing after fetching (as seen in grammar.js)\n  // This service will return the raw day-filtered data. Processing can occur in the component or a helper.\n  if (error) return {\n    data: [],\n    error,\n    errorType\n  };\n  return {\n    data: filterDataByDays(data, days),\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadReadingData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  // Assuming reading data might be structured by language and then by day, similar to vocabulary.\n  // Or it could be a single file per language if not day-specific.\n  // Example path: /data/reading/[langKey].json or /data/reading/[langKey]/[day].json\n  // For now, let's assume a structure like vocabulary: one file per language, with day keys inside.\n  const filePath = `/data/reading/reading_${langKey}.json`;\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  if (error) return {\n    data: [],\n    error,\n    errorType\n  };\n  return {\n    data: filterDataByDays(data, days),\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadSpeakingPromptsData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  // Speaking prompts are often per language and then per day or category.\n  // Example path: /data/speaking/prompts_[langKey].json\n  const filePath = `/data/speaking/question/question_${langKey}.json`; // Path based on old speaking.js\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  if (error) return {\n    data: [],\n    error,\n    errorType\n  };\n  return {\n    data: filterDataByDays(data, days),\n    error: null,\n    errorType: null\n  };\n}\nexport async function loadWritingPromptsData(languageIdentifier, days) {\n  const langKey = getLanguageFileKey(languageIdentifier);\n  // Writing prompts could be similar, e.g., /data/writing/prompts_[langKey].json\n  // Based on writing.js, it seems to use 'story_prompts_en.json' and filters by day.\n  // We'll use the actual langKey here.\n  const filePath = `/data/writing/story_prompts_${langKey}.json`;\n  const {\n    data,\n    error,\n    errorType\n  } = await fetchJsonData(filePath);\n  // Default structure from writing.js if error or no data\n  const defaultData = {\n    what_happens_next: [],\n    what_happened_before: []\n  };\n  if (error) return {\n    data: defaultData,\n    error,\n    errorType\n  };\n  const dayFilteredData = filterDataByDays(data, days);\n\n  // Handle cases where dayFilteredData might not be the expected structure\n  // or if 'days' implies merging multiple day objects (if 'days' is an array)\n  if (Array.isArray(days) && Array.isArray(dayFilteredData)) {\n    // This merging logic might need to be more sophisticated depending on actual data structure\n    const mergedPrompts = {\n      what_happens_next: [],\n      what_happened_before: []\n    };\n    dayFilteredData.forEach(dayObj => {\n      if (dayObj && dayObj.what_happens_next) mergedPrompts.what_happens_next.push(...dayObj.what_happens_next);\n      if (dayObj && dayObj.what_happened_before) mergedPrompts.what_happened_before.push(...dayObj.what_happened_before);\n    });\n    return {\n      data: mergedPrompts,\n      error: null,\n      errorType: null\n    };\n  }\n\n  // If dayFilteredData is an object (single day selected) or null/undefined\n  return {\n    data: dayFilteredData && typeof dayFilteredData === 'object' && !Array.isArray(dayFilteredData) ? dayFilteredData : defaultData,\n    error: null,\n    errorType: null\n  };\n}\nconsole.log('[ExerciseDataService] Service loaded.');","map":{"version":3,"names":["fetchJsonData","filePath","response","fetch","ok","data","json","error","errorType","jsonError","console","errorContext","status","networkError","message","langFileMap","getLanguageFileKey","languageIdentifier","filterDataByDays","allData","days","Array","isArray","dayData","forEach","d","concat","loadVocabularyData","langKey","loadImageData","allImageData","imageDataForDays","filteredImages","filter","img","translations","loadOppositesData","mergedOpposites","reduce","acc","dayObj","loadGenderGrammarData","loadPossessivesData","filenameLangKey","loadVerbGrammarData","loadReadingData","loadSpeakingPromptsData","loadWritingPromptsData","defaultData","what_happens_next","what_happened_before","dayFilteredData","mergedPrompts","push","log"],"sources":["/workspaces/COSYlanguagesproject/src/utils/exerciseDataService.js"],"sourcesContent":["// frontend/src/utils/exerciseDataService.js\r\n\r\n/**\r\n * Generic function to fetch JSON data from a given file path.\r\n * Assumes paths are relative to the public folder or served from the root.\r\n * @param {string} filePath - The path to the JSON file.\r\n * @returns {Promise<{data: any, error: string|null, errorType: string|null}>}\r\n */\r\nasync function fetchJsonData(filePath) {\r\n  try {\r\n    // In a React app, paths for static assets in `public` are usually relative to the root.\r\n    // If your `data` folder is in `public`, paths would be like `/data/vocabulary/words/english.json`.\r\n    // If served via a specific route by a dev server or backend, adjust accordingly.\r\n    const response = await fetch(filePath); \r\n    if (response.ok) {\r\n      try {\r\n        const data = await response.json();\r\n        return { data, error: null, errorType: null };\r\n      } catch (jsonError) {\r\n        console.error(`Error parsing JSON from ${filePath}:`, jsonError);\r\n        return { data: null, error: 'Invalid JSON format', errorType: 'jsonError' };\r\n      }\r\n    } else {\r\n      const errorContext = `HTTP error ${response.status} while fetching ${filePath}`;\r\n      console.error(errorContext);\r\n      if (response.status === 404) {\r\n        return { data: null, error: `File not found: ${filePath}`, errorType: 'fileNotFound' };\r\n      }\r\n      return { data: null, error: `Failed to load data: ${errorContext}`, errorType: 'httpError' };\r\n    }\r\n  } catch (networkError) {\r\n    console.error(`Network error or other exception while loading data from ${filePath}:`, networkError);\r\n    return { data: null, error: `Network error: ${networkError.message}`, errorType: 'networkError' };\r\n  }\r\n}\r\n\r\nconst langFileMap = {\r\n  'COSYenglish': 'english',\r\n  'COSYfrançais': 'french', // This maps to 'french'\r\n  'COSYespañol': 'spanish',\r\n  'COSYitaliano': 'italian',\r\n  'COSYdeutsch': 'german',\r\n  'COSYportuguês': 'portuguese',\r\n  'ΚΟΖΥελληνικά': 'greek',\r\n  'ТАКОЙрусский': 'russian',\r\n  'ԾՈՍՅհայկական': 'armenian',\r\n  'COSYbrezhoneg': 'breton',\r\n  'COSYtatarça': 'tatar',\r\n  'COSYbashkort': 'bashkir'\r\n};\r\n\r\nfunction getLanguageFileKey(languageIdentifier) {\r\n  return langFileMap[languageIdentifier] || 'english'; // Default to English\r\n}\r\n\r\n/**\r\n * Processes fetched data based on selected day(s).\r\n * @param {object} allData - The entire data object fetched from JSON.\r\n * @param {string|string[]} days - The selected day or array of days.\r\n * @returns {Array|Object} - The filtered data for the selected day(s).\r\n */\r\nfunction filterDataByDays(allData, days) {\r\n  if (!allData) return Array.isArray(days) ? [] : {}; // Return empty array for multiple days, object for single/opposites\r\n  \r\n  let dayData;\r\n  if (Array.isArray(days)) {\r\n    dayData = [];\r\n    days.forEach(d => {\r\n      if (allData[d]) dayData = dayData.concat(allData[d]);\r\n    });\r\n  } else { // Single day or data structure not an array (like opposites)\r\n    if (typeof days === 'string' || typeof days === 'number') { // Ensure 'days' is a valid key\r\n        dayData = allData[days] || (typeof allData === 'object' && !Array.isArray(allData) ? {} : []);\r\n    } else { // If days is not a string/number (e.g. undefined, null), return all data or empty if not applicable\r\n        dayData = allData; // This might be the case for data not structured by day, like images.json root\r\n    }\r\n  }\r\n  return dayData;\r\n}\r\n\r\n\r\nexport async function loadVocabularyData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/vocabulary/words/${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType }; // Ensure consistent error structure\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadImageData(languageIdentifier, days) {\r\n  const filePath = `/data/vocabulary/images/images.json`; // Single file for all image metadata\r\n  const { data: allImageData, error, errorType } = await fetchJsonData(filePath);\r\n  \r\n  if (error) return { data: [], error, errorType };\r\n\r\n  const imageDataForDays = filterDataByDays(allImageData, days);\r\n  \r\n  // Filter images that have a translation for the current language\r\n  const filteredImages = Array.isArray(imageDataForDays) \r\n    ? imageDataForDays.filter(img => img.translations && img.translations[languageIdentifier])\r\n    : []; // If not an array (e.g. error or unexpected structure), return empty\r\n\r\n  return { data: filteredImages, error: null, errorType: null };\r\n}\r\n\r\nexport async function loadOppositesData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/vocabulary/opposites/${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: {}, error, errorType };\r\n  // Opposites might be an object where keys are days, and values are objects of word-opposite pairs.\r\n  // Or, if days is a single day, it directly returns the object for that day.\r\n  // filterDataByDays should handle this.\r\n  const dayData = filterDataByDays(data, days);\r\n\r\n  // If 'days' was an array, we need to merge the objects from each day.\r\n  if (Array.isArray(days) && Array.isArray(dayData)) {\r\n    const mergedOpposites = dayData.reduce((acc, dayObj) => ({ ...acc, ...dayObj }), {});\r\n    return { data: mergedOpposites, error: null, errorType: null };\r\n  }\r\n  \r\n  return { data: dayData, error: null, errorType: null };\r\n}\r\n\r\nexport async function loadGenderGrammarData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/grammar/gender/grammar_gender_${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadPossessivesData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Ensure langKey for filename is 'francais' if languageIdentifier is 'COSYfrançais' (which maps to 'french')\r\n  const filenameLangKey = langKey === 'french' ? 'francais' : langKey;\r\n  const filePath = `/data/grammar/possessives/${filenameLangKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  // Possessives data is an object where keys are day numbers and values are arrays of exercise items.\r\n  // If error, return empty object as per conventions for object-based data.\r\n  if (error) return { data: {}, error, errorType }; \r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadVerbGrammarData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/grammar/verbs/grammar_verbs_${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  // Verb data often needs more processing after fetching (as seen in grammar.js)\r\n  // This service will return the raw day-filtered data. Processing can occur in the component or a helper.\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadReadingData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Assuming reading data might be structured by language and then by day, similar to vocabulary.\r\n  // Or it could be a single file per language if not day-specific.\r\n  // Example path: /data/reading/[langKey].json or /data/reading/[langKey]/[day].json\r\n  // For now, let's assume a structure like vocabulary: one file per language, with day keys inside.\r\n  const filePath = `/data/reading/reading_${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadSpeakingPromptsData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Speaking prompts are often per language and then per day or category.\r\n  // Example path: /data/speaking/prompts_[langKey].json\r\n  const filePath = `/data/speaking/question/question_${langKey}.json`; // Path based on old speaking.js\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadWritingPromptsData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Writing prompts could be similar, e.g., /data/writing/prompts_[langKey].json\r\n  // Based on writing.js, it seems to use 'story_prompts_en.json' and filters by day.\r\n  // We'll use the actual langKey here.\r\n  const filePath = `/data/writing/story_prompts_${langKey}.json`; \r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  // Default structure from writing.js if error or no data\r\n  const defaultData = { what_happens_next: [], what_happened_before: [] };\r\n  if (error) return { data: defaultData, error, errorType };\r\n  \r\n  const dayFilteredData = filterDataByDays(data, days);\r\n\r\n  // Handle cases where dayFilteredData might not be the expected structure\r\n  // or if 'days' implies merging multiple day objects (if 'days' is an array)\r\n  if (Array.isArray(days) && Array.isArray(dayFilteredData)) {\r\n    // This merging logic might need to be more sophisticated depending on actual data structure\r\n    const mergedPrompts = { what_happens_next: [], what_happened_before: [] };\r\n    dayFilteredData.forEach(dayObj => {\r\n      if (dayObj && dayObj.what_happens_next) mergedPrompts.what_happens_next.push(...dayObj.what_happens_next);\r\n      if (dayObj && dayObj.what_happened_before) mergedPrompts.what_happened_before.push(...dayObj.what_happened_before);\r\n    });\r\n    return { data: mergedPrompts, error: null, errorType: null };\r\n  }\r\n  \r\n  // If dayFilteredData is an object (single day selected) or null/undefined\r\n  return { \r\n    data: (dayFilteredData && typeof dayFilteredData === 'object' && !Array.isArray(dayFilteredData)) ? dayFilteredData : defaultData, \r\n    error: null, \r\n    errorType: null \r\n  };\r\n}\r\n\r\nconsole.log('[ExerciseDataService] Service loaded.');\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}