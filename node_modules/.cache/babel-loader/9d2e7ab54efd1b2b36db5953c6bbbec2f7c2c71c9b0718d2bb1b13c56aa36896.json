{"ast":null,"code":"var _jsxFileName = \"/workspaces/COSYlanguagesproject/src/contexts/ProgressContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ProgressContext = /*#__PURE__*/createContext();\nconst SRS_STORAGE_KEY = 'COSY_SRS_DATA';\n\n// Define SRS intervals (in days) for proficiency buckets 0 through N\n// Bucket 0: New item or incorrect, review very soon (e.g., a few hours or same day).\n// Bucket 1: Learned, review in 1 day.\n// Bucket 2: Review in 3 days.\n// Bucket 3: Review in 7 days.\n// Bucket 4: Review in 14 days.\n// Bucket 5: Review in 30 days (considered \"mastered\" for current cycle)\nconst SRS_INTERVALS = [0.1, 1, 3, 7, 14, 30]; // 0.1 for ~2.4 hours for new/incorrect items\nconst MAX_PROFICIENCY_BUCKET = SRS_INTERVALS.length - 1;\nexport const useProgress = () => {\n  _s();\n  const context = useContext(ProgressContext);\n  if (!context) {\n    throw new Error('useProgress must be used within a ProgressProvider');\n  }\n  return context;\n};\n_s(useProgress, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const ProgressProvider = ({\n  children\n}) => {\n  _s2();\n  const [learningItems, setLearningItems] = useState({});\n  useEffect(() => {\n    try {\n      const savedData = localStorage.getItem(SRS_STORAGE_KEY);\n      if (savedData) {\n        setLearningItems(JSON.parse(savedData));\n      }\n      console.log(\"[ProgressContext] SRS data loaded from localStorage:\", savedData ? JSON.parse(savedData) : {});\n    } catch (error) {\n      console.error(\"[ProgressContext] Error loading SRS data from localStorage:\", error);\n    }\n  }, []);\n  useEffect(() => {\n    try {\n      localStorage.setItem(SRS_STORAGE_KEY, JSON.stringify(learningItems));\n      console.log(\"[ProgressContext] SRS data saved to localStorage:\", learningItems);\n    } catch (error) {\n      console.error(\"[ProgressContext] Error saving SRS data to localStorage:\", error);\n    }\n  }, [learningItems]);\n  const getLearningItemKey = useCallback((itemId, itemType, language) => {\n    // Ensure consistent key generation, e.g., by lowercasing and trimming parts if necessary,\n    // though for now, direct concatenation is used as per original GameState logic.\n    return `${String(language)}_${String(itemType)}_${String(itemId)}`;\n  }, []);\n  const getLearningItem = useCallback((itemId, itemType, language) => {\n    const itemKey = getLearningItemKey(itemId, itemType, language);\n    return learningItems[itemKey] || {\n      itemId: String(itemId),\n      itemType: String(itemType),\n      language: String(language),\n      proficiencyBucket: 0,\n      lastReviewedDate: null,\n      nextReviewDate: new Date().toISOString(),\n      // New items are due immediately\n      consecutiveCorrectAnswers: 0,\n      totalAttempts: 0,\n      totalCorrect: 0\n    };\n  }, [learningItems, getLearningItemKey]);\n  const scheduleReview = useCallback((itemId, itemType, language, isCorrect) => {\n    setLearningItems(prevItems => {\n      const itemKey = getLearningItemKey(itemId, itemType, language);\n      // Use the getLearningItem to ensure we have a base structure even if it's new\n      const currentItem = prevItems[itemKey] || getLearningItem(itemId, itemType, language);\n      const newItemData = {\n        ...currentItem\n      };\n      newItemData.totalAttempts = (newItemData.totalAttempts || 0) + 1;\n      newItemData.lastReviewedDate = new Date().toISOString();\n      if (isCorrect) {\n        newItemData.totalCorrect = (newItemData.totalCorrect || 0) + 1;\n        newItemData.consecutiveCorrectAnswers = (newItemData.consecutiveCorrectAnswers || 0) + 1;\n        newItemData.proficiencyBucket = Math.min(MAX_PROFICIENCY_BUCKET, (currentItem.proficiencyBucket || 0) + 1);\n      } else {\n        newItemData.consecutiveCorrectAnswers = 0;\n        // For incorrect answers, move back one bucket, or to bucket 0\n        newItemData.proficiencyBucket = Math.max(0, (currentItem.proficiencyBucket || 0) - 1);\n      }\n      const intervalDays = SRS_INTERVALS[newItemData.proficiencyBucket];\n      const nextReview = new Date();\n      if (intervalDays < 1) {\n        // Handle fractional days (hours)\n        nextReview.setTime(nextReview.getTime() + intervalDays * 24 * 60 * 60 * 1000);\n      } else {\n        nextReview.setDate(nextReview.getDate() + intervalDays);\n      }\n      newItemData.nextReviewDate = nextReview.toISOString();\n      console.log(`[ProgressContext] Processed review for: ${itemKey}, Correct: ${isCorrect}, New Bucket: ${newItemData.proficiencyBucket}, Next Review: ${newItemData.nextReviewDate}`);\n      return {\n        ...prevItems,\n        [itemKey]: newItemData\n      };\n    });\n  }, [getLearningItem, getLearningItemKey]);\n  const awardCorrectAnswer = useCallback((itemId, itemType, language) => {\n    console.log(`[ProgressContext] Correct answer for: ${itemType} - ${itemId} in ${language}`);\n    scheduleReview(itemId, itemType, language, true);\n  }, [scheduleReview]);\n  const awardIncorrectAnswer = useCallback((itemId, itemType, language) => {\n    console.log(`[ProgressContext] Incorrect answer for: ${itemType} - ${itemId} in ${language}`);\n    scheduleReview(itemId, itemType, language, false);\n  }, [scheduleReview]);\n  const getItemProficiency = useCallback((itemId, itemType, language) => {\n    const item = getLearningItem(itemId, itemType, language);\n    return item.proficiencyBucket;\n  }, [getLearningItem]);\n  const getDueReviewItems = useCallback((language = null, itemType = null, maxItems = 10) => {\n    const now = new Date().toISOString();\n    const dueItems = Object.values(learningItems).filter(item => {\n      const langMatch = language ? item.language === language : true;\n      const typeMatch = itemType ? item.itemType === itemType : true;\n      // Ensure nextReviewDate exists and is not in the future\n      const isDue = item.nextReviewDate && item.nextReviewDate <= now;\n      return langMatch && typeMatch && isDue;\n    }).sort((a, b) => new Date(a.nextReviewDate) - new Date(b.nextReviewDate)); // Oldest due first\n\n    console.log(`[ProgressContext] Getting due review items (lang: ${language}, type: ${itemType}). Found: ${dueItems.length} due out of ${Object.keys(learningItems).length} total.`);\n    return dueItems.slice(0, maxItems);\n  }, [learningItems]);\n  const resetAllSrsProgress = useCallback(() => {\n    setLearningItems({});\n    // localStorage.removeItem(SRS_STORAGE_KEY); // Handled by useEffect for learningItems\n    console.log(\"[ProgressContext] All SRS progress has been reset.\");\n  }, []);\n  const value = {\n    awardCorrectAnswer,\n    awardIncorrectAnswer,\n    scheduleReview,\n    getItemProficiency,\n    getDueReviewItems,\n    learningItems,\n    resetAllSrsProgress,\n    getLearningItem // Exposing for potential direct use or inspection\n  };\n  return /*#__PURE__*/_jsxDEV(ProgressContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 155,\n    columnNumber: 5\n  }, this);\n};\n_s2(ProgressProvider, \"zle78YI4OjfJN2kr6lr9GlkYkww=\");\n_c = ProgressProvider;\nvar _c;\n$RefreshReg$(_c, \"ProgressProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useEffect","jsxDEV","_jsxDEV","ProgressContext","SRS_STORAGE_KEY","SRS_INTERVALS","MAX_PROFICIENCY_BUCKET","length","useProgress","_s","context","Error","ProgressProvider","children","_s2","learningItems","setLearningItems","savedData","localStorage","getItem","JSON","parse","console","log","error","setItem","stringify","getLearningItemKey","itemId","itemType","language","String","getLearningItem","itemKey","proficiencyBucket","lastReviewedDate","nextReviewDate","Date","toISOString","consecutiveCorrectAnswers","totalAttempts","totalCorrect","scheduleReview","isCorrect","prevItems","currentItem","newItemData","Math","min","max","intervalDays","nextReview","setTime","getTime","setDate","getDate","awardCorrectAnswer","awardIncorrectAnswer","getItemProficiency","item","getDueReviewItems","maxItems","now","dueItems","Object","values","filter","langMatch","typeMatch","isDue","sort","a","b","keys","slice","resetAllSrsProgress","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/workspaces/COSYlanguagesproject/src/contexts/ProgressContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';\r\n\r\nconst ProgressContext = createContext();\r\nconst SRS_STORAGE_KEY = 'COSY_SRS_DATA';\r\n\r\n// Define SRS intervals (in days) for proficiency buckets 0 through N\r\n// Bucket 0: New item or incorrect, review very soon (e.g., a few hours or same day).\r\n// Bucket 1: Learned, review in 1 day.\r\n// Bucket 2: Review in 3 days.\r\n// Bucket 3: Review in 7 days.\r\n// Bucket 4: Review in 14 days.\r\n// Bucket 5: Review in 30 days (considered \"mastered\" for current cycle)\r\nconst SRS_INTERVALS = [0.1, 1, 3, 7, 14, 30]; // 0.1 for ~2.4 hours for new/incorrect items\r\nconst MAX_PROFICIENCY_BUCKET = SRS_INTERVALS.length - 1;\r\n\r\nexport const useProgress = () => {\r\n  const context = useContext(ProgressContext);\r\n  if (!context) {\r\n    throw new Error('useProgress must be used within a ProgressProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport const ProgressProvider = ({ children }) => {\r\n  const [learningItems, setLearningItems] = useState({});\r\n\r\n  useEffect(() => {\r\n    try {\r\n      const savedData = localStorage.getItem(SRS_STORAGE_KEY);\r\n      if (savedData) {\r\n        setLearningItems(JSON.parse(savedData));\r\n      }\r\n      console.log(\"[ProgressContext] SRS data loaded from localStorage:\", savedData ? JSON.parse(savedData) : {});\r\n    } catch (error) {\r\n      console.error(\"[ProgressContext] Error loading SRS data from localStorage:\", error);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    try {\r\n      localStorage.setItem(SRS_STORAGE_KEY, JSON.stringify(learningItems));\r\n      console.log(\"[ProgressContext] SRS data saved to localStorage:\", learningItems);\r\n    } catch (error) {\r\n      console.error(\"[ProgressContext] Error saving SRS data to localStorage:\", error);\r\n    }\r\n  }, [learningItems]);\r\n\r\n  const getLearningItemKey = useCallback((itemId, itemType, language) => {\r\n    // Ensure consistent key generation, e.g., by lowercasing and trimming parts if necessary,\r\n    // though for now, direct concatenation is used as per original GameState logic.\r\n    return `${String(language)}_${String(itemType)}_${String(itemId)}`;\r\n  }, []);\r\n  \r\n  const getLearningItem = useCallback((itemId, itemType, language) => {\r\n    const itemKey = getLearningItemKey(itemId, itemType, language);\r\n    return learningItems[itemKey] || {\r\n      itemId: String(itemId),\r\n      itemType: String(itemType),\r\n      language: String(language),\r\n      proficiencyBucket: 0,\r\n      lastReviewedDate: null,\r\n      nextReviewDate: new Date().toISOString(), // New items are due immediately\r\n      consecutiveCorrectAnswers: 0,\r\n      totalAttempts: 0,\r\n      totalCorrect: 0,\r\n    };\r\n  }, [learningItems, getLearningItemKey]);\r\n\r\n  const scheduleReview = useCallback((itemId, itemType, language, isCorrect) => {\r\n    setLearningItems(prevItems => {\r\n      const itemKey = getLearningItemKey(itemId, itemType, language);\r\n      // Use the getLearningItem to ensure we have a base structure even if it's new\r\n      const currentItem = prevItems[itemKey] || getLearningItem(itemId, itemType, language);\r\n      \r\n      const newItemData = { ...currentItem };\r\n      newItemData.totalAttempts = (newItemData.totalAttempts || 0) + 1;\r\n      newItemData.lastReviewedDate = new Date().toISOString();\r\n\r\n      if (isCorrect) {\r\n        newItemData.totalCorrect = (newItemData.totalCorrect || 0) + 1;\r\n        newItemData.consecutiveCorrectAnswers = (newItemData.consecutiveCorrectAnswers || 0) + 1;\r\n        newItemData.proficiencyBucket = Math.min(MAX_PROFICIENCY_BUCKET, (currentItem.proficiencyBucket || 0) + 1);\r\n      } else {\r\n        newItemData.consecutiveCorrectAnswers = 0;\r\n        // For incorrect answers, move back one bucket, or to bucket 0\r\n        newItemData.proficiencyBucket = Math.max(0, (currentItem.proficiencyBucket || 0) - 1); \r\n      }\r\n      \r\n      const intervalDays = SRS_INTERVALS[newItemData.proficiencyBucket];\r\n      const nextReview = new Date();\r\n      if (intervalDays < 1) { // Handle fractional days (hours)\r\n        nextReview.setTime(nextReview.getTime() + intervalDays * 24 * 60 * 60 * 1000);\r\n      } else {\r\n        nextReview.setDate(nextReview.getDate() + intervalDays);\r\n      }\r\n      newItemData.nextReviewDate = nextReview.toISOString();\r\n\r\n      console.log(`[ProgressContext] Processed review for: ${itemKey}, Correct: ${isCorrect}, New Bucket: ${newItemData.proficiencyBucket}, Next Review: ${newItemData.nextReviewDate}`);\r\n      return {\r\n        ...prevItems,\r\n        [itemKey]: newItemData,\r\n      };\r\n    });\r\n  }, [getLearningItem, getLearningItemKey]);\r\n  \r\n  const awardCorrectAnswer = useCallback((itemId, itemType, language) => {\r\n    console.log(`[ProgressContext] Correct answer for: ${itemType} - ${itemId} in ${language}`);\r\n    scheduleReview(itemId, itemType, language, true);\r\n  }, [scheduleReview]);\r\n\r\n  const awardIncorrectAnswer = useCallback((itemId, itemType, language) => {\r\n    console.log(`[ProgressContext] Incorrect answer for: ${itemType} - ${itemId} in ${language}`);\r\n    scheduleReview(itemId, itemType, language, false);\r\n  }, [scheduleReview]);\r\n\r\n  const getItemProficiency = useCallback((itemId, itemType, language) => {\r\n    const item = getLearningItem(itemId, itemType, language);\r\n    return item.proficiencyBucket;\r\n  }, [getLearningItem]);\r\n\r\n  const getDueReviewItems = useCallback((language = null, itemType = null, maxItems = 10) => {\r\n    const now = new Date().toISOString();\r\n    const dueItems = Object.values(learningItems)\r\n      .filter(item => {\r\n        const langMatch = language ? item.language === language : true;\r\n        const typeMatch = itemType ? item.itemType === itemType : true;\r\n        // Ensure nextReviewDate exists and is not in the future\r\n        const isDue = item.nextReviewDate && item.nextReviewDate <= now;\r\n        return langMatch && typeMatch && isDue;\r\n      })\r\n      .sort((a, b) => new Date(a.nextReviewDate) - new Date(b.nextReviewDate)); // Oldest due first\r\n    \r\n    console.log(`[ProgressContext] Getting due review items (lang: ${language}, type: ${itemType}). Found: ${dueItems.length} due out of ${Object.keys(learningItems).length} total.`);\r\n    return dueItems.slice(0, maxItems);\r\n  }, [learningItems]);\r\n  \r\n  const resetAllSrsProgress = useCallback(() => {\r\n    setLearningItems({});\r\n    // localStorage.removeItem(SRS_STORAGE_KEY); // Handled by useEffect for learningItems\r\n    console.log(\"[ProgressContext] All SRS progress has been reset.\");\r\n  }, []);\r\n\r\n  const value = {\r\n    awardCorrectAnswer,\r\n    awardIncorrectAnswer,\r\n    scheduleReview, \r\n    getItemProficiency,\r\n    getDueReviewItems,\r\n    learningItems, \r\n    resetAllSrsProgress,\r\n    getLearningItem, // Exposing for potential direct use or inspection\r\n  };\r\n\r\n  return (\r\n    <ProgressContext.Provider value={value}>\r\n      {children}\r\n    </ProgressContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}