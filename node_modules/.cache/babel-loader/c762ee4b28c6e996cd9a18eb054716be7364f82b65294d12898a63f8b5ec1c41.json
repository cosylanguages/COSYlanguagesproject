{"ast":null,"code":"import _objectSpread from\"/workspaces/COSYlanguagesproject/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// frontend/src/utils/exerciseDataService.js\n/**\r\n * Generic function to fetch JSON data from a given file path.\r\n * Assumes paths are relative to the public folder or served from the root.\r\n * @param {string} filePath - The path to the JSON file.\r\n * @returns {Promise<{data: any, error: string|null, errorType: string|null}>}\r\n */async function fetchJsonData(filePath){try{// In a React app, paths for static assets in `public` are usually relative to the root.\n// If your `data` folder is in `public`, paths would be like `/data/vocabulary/words/english.json`.\n// If served via a specific route by a dev server or backend, adjust accordingly.\nconst response=await fetch(filePath);if(response.ok){try{const data=await response.json();return{data,error:null,errorType:null};}catch(jsonError){console.error(\"Error parsing JSON from \".concat(filePath,\":\"),jsonError);return{data:null,error:'Invalid JSON format',errorType:'jsonError'};}}else{const errorContext=\"HTTP error \".concat(response.status,\" while fetching \").concat(filePath);console.error(errorContext);if(response.status===404){return{data:null,error:\"File not found: \".concat(filePath),errorType:'fileNotFound'};}return{data:null,error:\"Failed to load data: \".concat(errorContext),errorType:'httpError'};}}catch(networkError){console.error(\"Network error or other exception while loading data from \".concat(filePath,\":\"),networkError);return{data:null,error:\"Network error: \".concat(networkError.message),errorType:'networkError'};}}const langFileMap={'COSYenglish':'english','COSYfrançais':'french',// This maps to 'french'\n'COSYespañol':'spanish','COSYitaliano':'italian','COSYdeutsch':'german','COSYportuguês':'portuguese','ΚΟΖΥελληνικά':'greek','ТАКОЙрусский':'russian','ԾՈՍՅհայկական':'armenian','COSYbrezhoneg':'breton','COSYtatarça':'tatar','COSYbashkort':'bashkir'};function getLanguageFileKey(languageIdentifier){return langFileMap[languageIdentifier]||'english';// Default to English\n}/**\r\n * Processes fetched data based on selected day(s).\r\n * @param {object} allData - The entire data object fetched from JSON.\r\n * @param {string|string[]} days - The selected day or array of days.\r\n * @returns {Array|Object} - The filtered data for the selected day(s).\r\n */function filterDataByDays(allData,days){if(!allData)return Array.isArray(days)?[]:{};// Return empty array for multiple days, object for single/opposites\nlet dayData;if(Array.isArray(days)){dayData=[];days.forEach(d=>{if(allData[d])dayData=dayData.concat(allData[d]);});}else{// Single day or data structure not an array (like opposites)\nif(typeof days==='string'||typeof days==='number'){// Ensure 'days' is a valid key\ndayData=allData[days]||(typeof allData==='object'&&!Array.isArray(allData)?{}:[]);}else{// If days is not a string/number (e.g. undefined, null), return all data or empty if not applicable\ndayData=allData;// This might be the case for data not structured by day, like images.json root\n}}return dayData;}export async function loadVocabularyData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);const filePath=\"/data/vocabulary/words/\".concat(langKey,\".json\");const{data,error,errorType}=await fetchJsonData(filePath);if(error)return{data:[],error,errorType};// Ensure consistent error structure\nreturn{data:filterDataByDays(data,days),error:null,errorType:null};}export async function loadImageData(languageIdentifier,days){const filePath=\"/data/vocabulary/images/images.json\";// Single file for all image metadata\nconst{data:allImageData,error,errorType}=await fetchJsonData(filePath);if(error)return{data:[],error,errorType};const imageDataForDays=filterDataByDays(allImageData,days);// Filter images that have a translation for the current language\nconst filteredImages=Array.isArray(imageDataForDays)?imageDataForDays.filter(img=>img.translations&&img.translations[languageIdentifier]):[];// If not an array (e.g. error or unexpected structure), return empty\nreturn{data:filteredImages,error:null,errorType:null};}export async function loadOppositesData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);const filePath=\"/data/vocabulary/opposites/\".concat(langKey,\".json\");const{data,error,errorType}=await fetchJsonData(filePath);if(error)return{data:{},error,errorType};// Opposites might be an object where keys are days, and values are objects of word-opposite pairs.\n// Or, if days is a single day, it directly returns the object for that day.\n// filterDataByDays should handle this.\nconst dayData=filterDataByDays(data,days);// If 'days' was an array, we need to merge the objects from each day.\nif(Array.isArray(days)&&Array.isArray(dayData)){const mergedOpposites=dayData.reduce((acc,dayObj)=>_objectSpread(_objectSpread({},acc),dayObj),{});return{data:mergedOpposites,error:null,errorType:null};}return{data:dayData,error:null,errorType:null};}export async function loadGenderGrammarData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);const filePath=\"/data/grammar/gender/grammar_gender_\".concat(langKey,\".json\");const{data,error,errorType}=await fetchJsonData(filePath);if(error)return{data:[],error,errorType};return{data:filterDataByDays(data,days),error:null,errorType:null};}export async function loadPossessivesData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);// Ensure langKey for filename is 'francais' if languageIdentifier is 'COSYfrançais' (which maps to 'french')\nconst filenameLangKey=langKey==='french'?'francais':langKey;const filePath=\"/data/grammar/possessives/\".concat(filenameLangKey,\".json\");const{data,error,errorType}=await fetchJsonData(filePath);// Possessives data is an object where keys are day numbers and values are arrays of exercise items.\n// If error, return empty object as per conventions for object-based data.\nif(error)return{data:{},error,errorType};return{data:filterDataByDays(data,days),error:null,errorType:null};}export async function loadVerbGrammarData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);const filePath=\"/data/grammar/verbs/grammar_verbs_\".concat(langKey,\".json\");const{data,error,errorType}=await fetchJsonData(filePath);// Verb data often needs more processing after fetching (as seen in grammar.js)\n// This service will return the raw day-filtered data. Processing can occur in the component or a helper.\nif(error)return{data:[],error,errorType};return{data:filterDataByDays(data,days),error:null,errorType:null};}export async function loadReadingData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);// Assuming reading data might be structured by language and then by day, similar to vocabulary.\n// Or it could be a single file per language if not day-specific.\n// Example path: /data/reading/[langKey].json or /data/reading/[langKey]/[day].json\n// For now, let's assume a structure like vocabulary: one file per language, with day keys inside.\nconst filePath=\"/data/reading/reading_\".concat(langKey,\".json\");const{data,error,errorType}=await fetchJsonData(filePath);if(error)return{data:[],error,errorType};return{data:filterDataByDays(data,days),error:null,errorType:null};}export async function loadSpeakingPromptsData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);// Speaking prompts are often per language and then per day or category.\n// Example path: /data/speaking/prompts_[langKey].json\nconst filePath=\"/data/speaking/question/question_\".concat(langKey,\".json\");// Path based on old speaking.js\nconst{data,error,errorType}=await fetchJsonData(filePath);if(error)return{data:[],error,errorType};return{data:filterDataByDays(data,days),error:null,errorType:null};}export async function loadWritingPromptsData(languageIdentifier,days){const langKey=getLanguageFileKey(languageIdentifier);// Writing prompts could be similar, e.g., /data/writing/prompts_[langKey].json\n// Based on writing.js, it seems to use 'story_prompts_en.json' and filters by day.\n// We'll use the actual langKey here.\nconst filePath=\"/data/writing/story_prompts_\".concat(langKey,\".json\");const{data,error,errorType}=await fetchJsonData(filePath);// Default structure from writing.js if error or no data\nconst defaultData={what_happens_next:[],what_happened_before:[]};if(error)return{data:defaultData,error,errorType};const dayFilteredData=filterDataByDays(data,days);// Handle cases where dayFilteredData might not be the expected structure\n// or if 'days' implies merging multiple day objects (if 'days' is an array)\nif(Array.isArray(days)&&Array.isArray(dayFilteredData)){// This merging logic might need to be more sophisticated depending on actual data structure\nconst mergedPrompts={what_happens_next:[],what_happened_before:[]};dayFilteredData.forEach(dayObj=>{if(dayObj&&dayObj.what_happens_next)mergedPrompts.what_happens_next.push(...dayObj.what_happens_next);if(dayObj&&dayObj.what_happened_before)mergedPrompts.what_happened_before.push(...dayObj.what_happened_before);});return{data:mergedPrompts,error:null,errorType:null};}// If dayFilteredData is an object (single day selected) or null/undefined\nreturn{data:dayFilteredData&&typeof dayFilteredData==='object'&&!Array.isArray(dayFilteredData)?dayFilteredData:defaultData,error:null,errorType:null};}console.log('[ExerciseDataService] Service loaded.');","map":{"version":3,"names":["fetchJsonData","filePath","response","fetch","ok","data","json","error","errorType","jsonError","console","concat","errorContext","status","networkError","message","langFileMap","getLanguageFileKey","languageIdentifier","filterDataByDays","allData","days","Array","isArray","dayData","forEach","d","loadVocabularyData","langKey","loadImageData","allImageData","imageDataForDays","filteredImages","filter","img","translations","loadOppositesData","mergedOpposites","reduce","acc","dayObj","_objectSpread","loadGenderGrammarData","loadPossessivesData","filenameLangKey","loadVerbGrammarData","loadReadingData","loadSpeakingPromptsData","loadWritingPromptsData","defaultData","what_happens_next","what_happened_before","dayFilteredData","mergedPrompts","push","log"],"sources":["/workspaces/COSYlanguagesproject/src/utils/exerciseDataService.js"],"sourcesContent":["// frontend/src/utils/exerciseDataService.js\r\n\r\n/**\r\n * Generic function to fetch JSON data from a given file path.\r\n * Assumes paths are relative to the public folder or served from the root.\r\n * @param {string} filePath - The path to the JSON file.\r\n * @returns {Promise<{data: any, error: string|null, errorType: string|null}>}\r\n */\r\nasync function fetchJsonData(filePath) {\r\n  try {\r\n    // In a React app, paths for static assets in `public` are usually relative to the root.\r\n    // If your `data` folder is in `public`, paths would be like `/data/vocabulary/words/english.json`.\r\n    // If served via a specific route by a dev server or backend, adjust accordingly.\r\n    const response = await fetch(filePath); \r\n    if (response.ok) {\r\n      try {\r\n        const data = await response.json();\r\n        return { data, error: null, errorType: null };\r\n      } catch (jsonError) {\r\n        console.error(`Error parsing JSON from ${filePath}:`, jsonError);\r\n        return { data: null, error: 'Invalid JSON format', errorType: 'jsonError' };\r\n      }\r\n    } else {\r\n      const errorContext = `HTTP error ${response.status} while fetching ${filePath}`;\r\n      console.error(errorContext);\r\n      if (response.status === 404) {\r\n        return { data: null, error: `File not found: ${filePath}`, errorType: 'fileNotFound' };\r\n      }\r\n      return { data: null, error: `Failed to load data: ${errorContext}`, errorType: 'httpError' };\r\n    }\r\n  } catch (networkError) {\r\n    console.error(`Network error or other exception while loading data from ${filePath}:`, networkError);\r\n    return { data: null, error: `Network error: ${networkError.message}`, errorType: 'networkError' };\r\n  }\r\n}\r\n\r\nconst langFileMap = {\r\n  'COSYenglish': 'english',\r\n  'COSYfrançais': 'french', // This maps to 'french'\r\n  'COSYespañol': 'spanish',\r\n  'COSYitaliano': 'italian',\r\n  'COSYdeutsch': 'german',\r\n  'COSYportuguês': 'portuguese',\r\n  'ΚΟΖΥελληνικά': 'greek',\r\n  'ТАКОЙрусский': 'russian',\r\n  'ԾՈՍՅհայկական': 'armenian',\r\n  'COSYbrezhoneg': 'breton',\r\n  'COSYtatarça': 'tatar',\r\n  'COSYbashkort': 'bashkir'\r\n};\r\n\r\nfunction getLanguageFileKey(languageIdentifier) {\r\n  return langFileMap[languageIdentifier] || 'english'; // Default to English\r\n}\r\n\r\n/**\r\n * Processes fetched data based on selected day(s).\r\n * @param {object} allData - The entire data object fetched from JSON.\r\n * @param {string|string[]} days - The selected day or array of days.\r\n * @returns {Array|Object} - The filtered data for the selected day(s).\r\n */\r\nfunction filterDataByDays(allData, days) {\r\n  if (!allData) return Array.isArray(days) ? [] : {}; // Return empty array for multiple days, object for single/opposites\r\n  \r\n  let dayData;\r\n  if (Array.isArray(days)) {\r\n    dayData = [];\r\n    days.forEach(d => {\r\n      if (allData[d]) dayData = dayData.concat(allData[d]);\r\n    });\r\n  } else { // Single day or data structure not an array (like opposites)\r\n    if (typeof days === 'string' || typeof days === 'number') { // Ensure 'days' is a valid key\r\n        dayData = allData[days] || (typeof allData === 'object' && !Array.isArray(allData) ? {} : []);\r\n    } else { // If days is not a string/number (e.g. undefined, null), return all data or empty if not applicable\r\n        dayData = allData; // This might be the case for data not structured by day, like images.json root\r\n    }\r\n  }\r\n  return dayData;\r\n}\r\n\r\n\r\nexport async function loadVocabularyData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/vocabulary/words/${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType }; // Ensure consistent error structure\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadImageData(languageIdentifier, days) {\r\n  const filePath = `/data/vocabulary/images/images.json`; // Single file for all image metadata\r\n  const { data: allImageData, error, errorType } = await fetchJsonData(filePath);\r\n  \r\n  if (error) return { data: [], error, errorType };\r\n\r\n  const imageDataForDays = filterDataByDays(allImageData, days);\r\n  \r\n  // Filter images that have a translation for the current language\r\n  const filteredImages = Array.isArray(imageDataForDays) \r\n    ? imageDataForDays.filter(img => img.translations && img.translations[languageIdentifier])\r\n    : []; // If not an array (e.g. error or unexpected structure), return empty\r\n\r\n  return { data: filteredImages, error: null, errorType: null };\r\n}\r\n\r\nexport async function loadOppositesData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/vocabulary/opposites/${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: {}, error, errorType };\r\n  // Opposites might be an object where keys are days, and values are objects of word-opposite pairs.\r\n  // Or, if days is a single day, it directly returns the object for that day.\r\n  // filterDataByDays should handle this.\r\n  const dayData = filterDataByDays(data, days);\r\n\r\n  // If 'days' was an array, we need to merge the objects from each day.\r\n  if (Array.isArray(days) && Array.isArray(dayData)) {\r\n    const mergedOpposites = dayData.reduce((acc, dayObj) => ({ ...acc, ...dayObj }), {});\r\n    return { data: mergedOpposites, error: null, errorType: null };\r\n  }\r\n  \r\n  return { data: dayData, error: null, errorType: null };\r\n}\r\n\r\nexport async function loadGenderGrammarData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/grammar/gender/grammar_gender_${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadPossessivesData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Ensure langKey for filename is 'francais' if languageIdentifier is 'COSYfrançais' (which maps to 'french')\r\n  const filenameLangKey = langKey === 'french' ? 'francais' : langKey;\r\n  const filePath = `/data/grammar/possessives/${filenameLangKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  // Possessives data is an object where keys are day numbers and values are arrays of exercise items.\r\n  // If error, return empty object as per conventions for object-based data.\r\n  if (error) return { data: {}, error, errorType }; \r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadVerbGrammarData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  const filePath = `/data/grammar/verbs/grammar_verbs_${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  // Verb data often needs more processing after fetching (as seen in grammar.js)\r\n  // This service will return the raw day-filtered data. Processing can occur in the component or a helper.\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadReadingData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Assuming reading data might be structured by language and then by day, similar to vocabulary.\r\n  // Or it could be a single file per language if not day-specific.\r\n  // Example path: /data/reading/[langKey].json or /data/reading/[langKey]/[day].json\r\n  // For now, let's assume a structure like vocabulary: one file per language, with day keys inside.\r\n  const filePath = `/data/reading/reading_${langKey}.json`;\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadSpeakingPromptsData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Speaking prompts are often per language and then per day or category.\r\n  // Example path: /data/speaking/prompts_[langKey].json\r\n  const filePath = `/data/speaking/question/question_${langKey}.json`; // Path based on old speaking.js\r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  if (error) return { data: [], error, errorType };\r\n  return { data: filterDataByDays(data, days), error: null, errorType: null };\r\n}\r\n\r\nexport async function loadWritingPromptsData(languageIdentifier, days) {\r\n  const langKey = getLanguageFileKey(languageIdentifier);\r\n  // Writing prompts could be similar, e.g., /data/writing/prompts_[langKey].json\r\n  // Based on writing.js, it seems to use 'story_prompts_en.json' and filters by day.\r\n  // We'll use the actual langKey here.\r\n  const filePath = `/data/writing/story_prompts_${langKey}.json`; \r\n  const { data, error, errorType } = await fetchJsonData(filePath);\r\n  // Default structure from writing.js if error or no data\r\n  const defaultData = { what_happens_next: [], what_happened_before: [] };\r\n  if (error) return { data: defaultData, error, errorType };\r\n  \r\n  const dayFilteredData = filterDataByDays(data, days);\r\n\r\n  // Handle cases where dayFilteredData might not be the expected structure\r\n  // or if 'days' implies merging multiple day objects (if 'days' is an array)\r\n  if (Array.isArray(days) && Array.isArray(dayFilteredData)) {\r\n    // This merging logic might need to be more sophisticated depending on actual data structure\r\n    const mergedPrompts = { what_happens_next: [], what_happened_before: [] };\r\n    dayFilteredData.forEach(dayObj => {\r\n      if (dayObj && dayObj.what_happens_next) mergedPrompts.what_happens_next.push(...dayObj.what_happens_next);\r\n      if (dayObj && dayObj.what_happened_before) mergedPrompts.what_happened_before.push(...dayObj.what_happened_before);\r\n    });\r\n    return { data: mergedPrompts, error: null, errorType: null };\r\n  }\r\n  \r\n  // If dayFilteredData is an object (single day selected) or null/undefined\r\n  return { \r\n    data: (dayFilteredData && typeof dayFilteredData === 'object' && !Array.isArray(dayFilteredData)) ? dayFilteredData : defaultData, \r\n    error: null, \r\n    errorType: null \r\n  };\r\n}\r\n\r\nconsole.log('[ExerciseDataService] Service loaded.');\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}