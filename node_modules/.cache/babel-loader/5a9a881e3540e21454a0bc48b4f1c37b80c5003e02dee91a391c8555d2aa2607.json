{"ast":null,"code":"/**\r\n * Shuffles an array in place and returns a new shuffled array.\r\n * @param {Array} array - The array to shuffle.\r\n * @returns {Array} A new array with the elements randomly shuffled.\r\n */\nexport function shuffleArray(array) {\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n}\n\n/**\r\n * Selects a random item from an array of items, where each item has a weight.\r\n * @param {Array<{item: any, weight: number}>} itemsWithWeights - An array of objects,\r\n * each with an 'item' and its 'weight'.\r\n * @returns {any|null} The selected item, or null if the input is invalid or empty.\r\n */\nexport function getWeightedRandomItem(itemsWithWeights) {\n  if (!itemsWithWeights || itemsWithWeights.length === 0) {\n    return null;\n  }\n  const totalWeight = itemsWithWeights.reduce((sum, entry) => sum + (entry.weight || 0), 0);\n  if (totalWeight <= 0) {\n    // If total weight is 0 (e.g., all weights are 0 or negative), fall back to uniform random selection.\n    const originalItems = itemsWithWeights.map(iw => iw.item);\n    return originalItems.length > 0 ? originalItems[Math.floor(Math.random() * originalItems.length)] : null;\n  }\n  let randomValue = Math.random() * totalWeight;\n  for (let i = 0; i < itemsWithWeights.length; i++) {\n    if (randomValue < (itemsWithWeights[i].weight || 0)) {\n      return itemsWithWeights[i].item;\n    }\n    randomValue -= itemsWithWeights[i].weight || 0;\n  }\n\n  // Fallback in case of rounding errors or unexpected scenarios, though theoretically should be covered.\n  const originalItems = itemsWithWeights.map(iw => iw.item);\n  return originalItems.length > 0 ? originalItems[Math.floor(Math.random() * originalItems.length)] : null;\n}","map":{"version":3,"names":["shuffleArray","array","newArray","i","length","j","Math","floor","random","getWeightedRandomItem","itemsWithWeights","totalWeight","reduce","sum","entry","weight","originalItems","map","iw","item","randomValue"],"sources":["/workspaces/COSYlanguagesproject/src/utils/arrayUtils.js"],"sourcesContent":["/**\r\n * Shuffles an array in place and returns a new shuffled array.\r\n * @param {Array} array - The array to shuffle.\r\n * @returns {Array} A new array with the elements randomly shuffled.\r\n */\r\nexport function shuffleArray(array) {\r\n  const newArray = [...array];\r\n  for (let i = newArray.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\r\n  }\r\n  return newArray;\r\n}\r\n\r\n/**\r\n * Selects a random item from an array of items, where each item has a weight.\r\n * @param {Array<{item: any, weight: number}>} itemsWithWeights - An array of objects,\r\n * each with an 'item' and its 'weight'.\r\n * @returns {any|null} The selected item, or null if the input is invalid or empty.\r\n */\r\nexport function getWeightedRandomItem(itemsWithWeights) {\r\n  if (!itemsWithWeights || itemsWithWeights.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const totalWeight = itemsWithWeights.reduce((sum, entry) => sum + (entry.weight || 0), 0);\r\n  if (totalWeight <= 0) {\r\n    // If total weight is 0 (e.g., all weights are 0 or negative), fall back to uniform random selection.\r\n    const originalItems = itemsWithWeights.map(iw => iw.item);\r\n    return originalItems.length > 0 ? originalItems[Math.floor(Math.random() * originalItems.length)] : null;\r\n  }\r\n\r\n  let randomValue = Math.random() * totalWeight;\r\n  for (let i = 0; i < itemsWithWeights.length; i++) {\r\n    if (randomValue < (itemsWithWeights[i].weight || 0)) {\r\n      return itemsWithWeights[i].item;\r\n    }\r\n    randomValue -= (itemsWithWeights[i].weight || 0);\r\n  }\r\n  \r\n  // Fallback in case of rounding errors or unexpected scenarios, though theoretically should be covered.\r\n  const originalItems = itemsWithWeights.map(iw => iw.item);\r\n  return originalItems.length > 0 ? originalItems[Math.floor(Math.random() * originalItems.length)] : null;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,YAAYA,CAACC,KAAK,EAAE;EAClC,MAAMC,QAAQ,GAAG,CAAC,GAAGD,KAAK,CAAC;EAC3B,KAAK,IAAIE,CAAC,GAAGD,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC5C,MAAME,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIL,CAAC,GAAG,CAAC,CAAC,CAAC;IAC7C,CAACD,QAAQ,CAACC,CAAC,CAAC,EAAED,QAAQ,CAACG,CAAC,CAAC,CAAC,GAAG,CAACH,QAAQ,CAACG,CAAC,CAAC,EAAEH,QAAQ,CAACC,CAAC,CAAC,CAAC;EACzD;EACA,OAAOD,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,qBAAqBA,CAACC,gBAAgB,EAAE;EACtD,IAAI,CAACA,gBAAgB,IAAIA,gBAAgB,CAACN,MAAM,KAAK,CAAC,EAAE;IACtD,OAAO,IAAI;EACb;EAEA,MAAMO,WAAW,GAAGD,gBAAgB,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAIC,KAAK,CAACC,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;EACzF,IAAIJ,WAAW,IAAI,CAAC,EAAE;IACpB;IACA,MAAMK,aAAa,GAAGN,gBAAgB,CAACO,GAAG,CAACC,EAAE,IAAIA,EAAE,CAACC,IAAI,CAAC;IACzD,OAAOH,aAAa,CAACZ,MAAM,GAAG,CAAC,GAAGY,aAAa,CAACV,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGQ,aAAa,CAACZ,MAAM,CAAC,CAAC,GAAG,IAAI;EAC1G;EAEA,IAAIgB,WAAW,GAAGd,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGG,WAAW;EAC7C,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,gBAAgB,CAACN,MAAM,EAAED,CAAC,EAAE,EAAE;IAChD,IAAIiB,WAAW,IAAIV,gBAAgB,CAACP,CAAC,CAAC,CAACY,MAAM,IAAI,CAAC,CAAC,EAAE;MACnD,OAAOL,gBAAgB,CAACP,CAAC,CAAC,CAACgB,IAAI;IACjC;IACAC,WAAW,IAAKV,gBAAgB,CAACP,CAAC,CAAC,CAACY,MAAM,IAAI,CAAE;EAClD;;EAEA;EACA,MAAMC,aAAa,GAAGN,gBAAgB,CAACO,GAAG,CAACC,EAAE,IAAIA,EAAE,CAACC,IAAI,CAAC;EACzD,OAAOH,aAAa,CAACZ,MAAM,GAAG,CAAC,GAAGY,aAAa,CAACV,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGQ,aAAa,CAACZ,MAAM,CAAC,CAAC,GAAG,IAAI;AAC1G","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}