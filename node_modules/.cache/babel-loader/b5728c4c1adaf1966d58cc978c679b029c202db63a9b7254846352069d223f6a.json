{"ast":null,"code":"import React,{createContext,useContext,useState,useCallback,useEffect}from'react';import{loginTeacher as apiLoginTeacher,logoutUser as apiLogoutUser}from'./api/auth';import{jsx as _jsx}from\"react/jsx-runtime\";export const AuthContext=/*#__PURE__*/createContext();export function useAuth(){return useContext(AuthContext);}export function AuthProvider(_ref){let{children}=_ref;const[authToken,setAuthToken]=useState(sessionStorage.getItem('authToken'));const[currentUser,setCurrentUser]=useState(()=>{try{const item=sessionStorage.getItem('currentUser');return item?JSON.parse(item):null;}catch(error){console.error(\"Error parsing currentUser from sessionStorage:\",error);sessionStorage.removeItem('currentUser');// Clear corrupted item\nreturn null;}});const[authError,setAuthError]=useState(null);const[loadingAuth,setLoadingAuth]=useState(false);// Effect to update sessionStorage when authToken or currentUser changes\nuseEffect(()=>{if(authToken){sessionStorage.setItem('authToken',authToken);}else{sessionStorage.removeItem('authToken');}},[authToken]);useEffect(()=>{if(currentUser){sessionStorage.setItem('currentUser',JSON.stringify(currentUser));}else{sessionStorage.removeItem('currentUser');}},[currentUser]);const login=useCallback(async pin=>{setLoadingAuth(true);setAuthError(null);try{const data=await apiLoginTeacher(pin);setAuthToken(data.token);setCurrentUser({id:data.userId,role:data.role,username:data.username});// Assuming username might come from API\nreturn true;}catch(err){console.error(\"Error during login:\",err);setAuthError(err.message||'Failed to login');setAuthToken(null);setCurrentUser(null);return false;}finally{setLoadingAuth(false);}},[]);const logout=useCallback(async()=>{setLoadingAuth(true);setAuthError(null);if(authToken){try{await apiLogoutUser(authToken);}catch(err){// Log error but proceed with client-side logout anyway\nconsole.error(\"Error during API logout:\",err);setAuthError(err.message||'Failed to logout from server, logged out locally.');}}setAuthToken(null);setCurrentUser(null);sessionStorage.removeItem('authToken');// Ensure removal\nsessionStorage.removeItem('currentUser');setLoadingAuth(false);// Optionally, redirect to login or home page via useNavigate if used here\n},[authToken]);// Check token validity on initial load (optional, depends on backend token check endpoint)\n// For now, we rely on sessionStorage and assume token is valid if present.\n// A more robust solution would verify the token with the backend here.\nconst value={authToken,currentUser,isAuthenticated:!!authToken&&!!currentUser,authError,loadingAuth,login,logout};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:value,children:children});}","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useEffect","loginTeacher","apiLoginTeacher","logoutUser","apiLogoutUser","jsx","_jsx","AuthContext","useAuth","AuthProvider","_ref","children","authToken","setAuthToken","sessionStorage","getItem","currentUser","setCurrentUser","item","JSON","parse","error","console","removeItem","authError","setAuthError","loadingAuth","setLoadingAuth","setItem","stringify","login","pin","data","token","id","userId","role","username","err","message","logout","value","isAuthenticated","Provider"],"sources":["/workspaces/COSYlanguagesproject/src/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';\r\nimport { loginTeacher as apiLoginTeacher, logoutUser as apiLogoutUser } from './api/auth';\r\n\r\nexport const AuthContext = createContext();\r\n\r\nexport function useAuth() {\r\n    return useContext(AuthContext);\r\n}\r\n\r\nexport function AuthProvider({ children }) {\r\n    const [authToken, setAuthToken] = useState(sessionStorage.getItem('authToken'));\r\n    const [currentUser, setCurrentUser] = useState(() => {\r\n        try {\r\n            const item = sessionStorage.getItem('currentUser');\r\n            return item ? JSON.parse(item) : null;\r\n        } catch (error) {\r\n            console.error(\"Error parsing currentUser from sessionStorage:\", error);\r\n            sessionStorage.removeItem('currentUser'); // Clear corrupted item\r\n            return null;\r\n        }\r\n    });\r\n    const [authError, setAuthError] = useState(null);\r\n    const [loadingAuth, setLoadingAuth] = useState(false);\r\n\r\n    // Effect to update sessionStorage when authToken or currentUser changes\r\n    useEffect(() => {\r\n        if (authToken) {\r\n            sessionStorage.setItem('authToken', authToken);\r\n        } else {\r\n            sessionStorage.removeItem('authToken');\r\n        }\r\n    }, [authToken]);\r\n\r\n    useEffect(() => {\r\n        if (currentUser) {\r\n            sessionStorage.setItem('currentUser', JSON.stringify(currentUser));\r\n        } else {\r\n            sessionStorage.removeItem('currentUser');\r\n        }\r\n    }, [currentUser]);\r\n\r\n    const login = useCallback(async (pin) => {\r\n        setLoadingAuth(true);\r\n        setAuthError(null);\r\n        try {\r\n            const data = await apiLoginTeacher(pin);\r\n            setAuthToken(data.token);\r\n            setCurrentUser({ id: data.userId, role: data.role, username: data.username }); // Assuming username might come from API\r\n            return true;\r\n        } catch (err) {\r\n            console.error(\"Error during login:\", err);\r\n            setAuthError(err.message || 'Failed to login');\r\n            setAuthToken(null);\r\n            setCurrentUser(null);\r\n            return false;\r\n        } finally {\r\n            setLoadingAuth(false);\r\n        }\r\n    }, []);\r\n\r\n    const logout = useCallback(async () => {\r\n        setLoadingAuth(true);\r\n        setAuthError(null);\r\n        if (authToken) {\r\n            try {\r\n                await apiLogoutUser(authToken);\r\n            } catch (err) {\r\n                // Log error but proceed with client-side logout anyway\r\n                console.error(\"Error during API logout:\", err);\r\n                setAuthError(err.message || 'Failed to logout from server, logged out locally.');\r\n            }\r\n        }\r\n        setAuthToken(null);\r\n        setCurrentUser(null);\r\n        sessionStorage.removeItem('authToken'); // Ensure removal\r\n        sessionStorage.removeItem('currentUser');\r\n        setLoadingAuth(false);\r\n        // Optionally, redirect to login or home page via useNavigate if used here\r\n    }, [authToken]);\r\n\r\n    // Check token validity on initial load (optional, depends on backend token check endpoint)\r\n    // For now, we rely on sessionStorage and assume token is valid if present.\r\n    // A more robust solution would verify the token with the backend here.\r\n\r\n    const value = {\r\n        authToken,\r\n        currentUser,\r\n        isAuthenticated: !!authToken && !!currentUser,\r\n        authError,\r\n        loadingAuth,\r\n        login,\r\n        logout,\r\n    };\r\n\r\n    return (\r\n        <AuthContext.Provider value={value}>\r\n            {children}\r\n        </AuthContext.Provider>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}