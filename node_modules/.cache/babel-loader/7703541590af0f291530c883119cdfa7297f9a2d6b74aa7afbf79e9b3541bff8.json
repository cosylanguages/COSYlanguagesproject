{"ast":null,"code":"import { shuffleArray } from './arrayUtils';\nimport { capitalizeWord, escapeRegExp } from './stringUtils';\nimport { loadVocabularyData } from './exerciseDataService'; // For fetching vocabulary for objects\n\n// This will hold translations, to be populated ideally by I18nContext or similar\n// For now, using a simple placeholder. In a real app, this should be managed by an i18n solution.\nlet currentTranslations = {\n  COSYenglish: {\n    defaultAdjective: \"happy\",\n    defaultNounWithArticle: \"a cat\",\n    defaultNoun: \"cat\",\n    defaultAdverb: \"well\",\n    infinitiveMarker: \"to \",\n    verbToBe: \"to be\",\n    verbToHave: \"to have\",\n    negationParticle: \"not\",\n    pronoun_they: \"they\",\n    pronoun_he: \"he\",\n    pronoun_she: \"she\",\n    pronoun_it: \"it\",\n    conjunction_and: \"and\",\n    commonNames: [\"Alex\", \"Maria\", \"Sam\", \"Lee\", \"Jordan\", \"Taylor\", \"Chris\", \"Pat\"],\n    genericObjectFallback: \"something\",\n    pluralPronounsList: ['we', 'they', 'you'],\n    // Simplified for example\n    sentenceEndingAdjective: \"happy.\",\n    sentenceEndingAdverb: \"well.\",\n    errorFallbackWord: \"error\"\n  }\n};\n\n// Function to update translations if needed (e.g., from context)\nexport function setGrammarGeneratorTranslations(translations) {\n  currentTranslations = translations;\n}\nconst COMMON_NAMES_EN = [\"Alex\", \"Maria\", \"Sam\", \"Lee\", \"Jordan\", \"Taylor\", \"Chris\", \"Pat\"];\nfunction getRandomElement(arr) {\n  if (!arr || arr.length === 0) return null;\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\n// Adapted from old grammar.js - specific to English for now\nfunction addIndefiniteArticle(nounStr, language) {\n  const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\n  if (language !== 'COSYenglish' || typeof nounStr !== 'string' || nounStr.trim() === '') {\n    return nounStr;\n  }\n  const trimmedNoun = nounStr.trim();\n  const articleRegex = /^(a|an|the)\\s/i;\n  if (articleRegex.test(trimmedNoun)) {\n    return nounStr;\n  }\n  const lowerNoun = trimmedNoun.toLowerCase();\n  const pronounsAndSomeNames = ['i', 'you', 'he', 'she', 'it', 'we', 'they', ...(t.commonNames || COMMON_NAMES_EN).map(n => n.toLowerCase())];\n  if (pronounsAndSomeNames.includes(lowerNoun)) {\n    return nounStr;\n  }\n  if (trimmedNoun.endsWith('s') && !trimmedNoun.endsWith('ss')) {\n    const knownSingularSEndings = ['bus', 'gas', 'lens', 'plus', 'status', 'species', 'series', 'news'];\n    if (!knownSingularSEndings.includes(lowerNoun)) {\n      return nounStr;\n    }\n  }\n  const firstLetter = trimmedNoun.charAt(0).toLowerCase();\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const exceptionsAn = ['hour', 'honest', 'honor', 'heir'];\n  const exceptionsA = ['user', 'university', 'uniform', 'european', 'one', 'unit'];\n  if (exceptionsAn.some(ex => lowerNoun.startsWith(ex))) return `an ${trimmedNoun}`;\n  if (exceptionsA.some(ex => lowerNoun.startsWith(ex))) return `a ${trimmedNoun}`;\n  if (vowels.includes(firstLetter)) {\n    return `an ${trimmedNoun}`;\n  } else {\n    return `a ${trimmedNoun}`;\n  }\n}\nasync function selectSubject(language, verbData, vocabularyList, allowCompound = true) {\n  const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\n  const typeRoll = Math.random();\n  let subject = {\n    text: \"it\",\n    type: \"pronoun\",\n    isPlural: false,\n    representativePronoun: \"it\"\n  };\n  const availablePronouns = [...new Set(verbData.map(vd => vd.pronoun).filter(p => p && !p.includes('/')))];\n  const simpleNouns = vocabularyList.filter(v => typeof v === 'string' && v.length > 1 && v.split(' ').length === 1);\n  const knownVerbForms = new Set(verbData.map(vd => vd.form.toLowerCase()));\n  const potentialNouns = simpleNouns.filter(n => !knownVerbForms.has(n.toLowerCase()));\n  let namesForLang = t.commonNames && t.commonNames.length > 0 ? t.commonNames : language === 'COSYenglish' ? COMMON_NAMES_EN : [];\n  if (typeRoll < 0.4 && availablePronouns.length > 0) {\n    const chosenPronoun = getRandomElement(availablePronouns);\n    subject.text = chosenPronoun;\n    subject.type = \"pronoun\";\n    const pluralPronouns = t.pluralPronounsList || ['we', 'they', 'you', 'nous', 'vous', 'ils', 'elles', 'wir', 'ihr', 'sie', 'voi', 'loro', 'nosotros', 'vosotros', 'ellos', 'ellas', 'ustedes', 'nós', 'vós', 'eles', 'elas', 'мы', 'вы', 'они', 'me', 'te', 'he'];\n    const singularPronouns = ['i', 'he', 'she', 'it', 'je', 'tu', 'il', 'elle', 'on', 'ich', 'du', 'er', 'es', 'io', 'lui', 'lei', 'yo', 'tú', 'él', 'ella', 'usted', 'eu', 'ele', 'ela', 'você', 'я', 'ты', 'он', 'она', 'оно', 'minä', 'sinä', 'hän'];\n    if (pluralPronouns.includes(chosenPronoun === null || chosenPronoun === void 0 ? void 0 : chosenPronoun.toLowerCase())) subject.isPlural = true;\n    if (singularPronouns.includes(chosenPronoun === null || chosenPronoun === void 0 ? void 0 : chosenPronoun.toLowerCase())) subject.isPlural = false;\n    subject.representativePronoun = chosenPronoun.toLowerCase();\n  } else if (typeRoll < 0.8 && (potentialNouns.length > 0 || namesForLang.length > 0)) {\n    const nounSourceRoll = Math.random();\n    let chosenNoun;\n    if (nounSourceRoll < 0.7 && potentialNouns.length > 0) {\n      chosenNoun = getRandomElement(potentialNouns);\n    } else if (namesForLang.length > 0) {\n      chosenNoun = getRandomElement(namesForLang);\n    } else {\n      chosenNoun = getRandomElement(potentialNouns);\n    }\n    subject.text = namesForLang.includes(chosenNoun) ? chosenNoun : chosenNoun.toLowerCase();\n    subject.type = \"noun\";\n    subject.isPlural = false;\n    if (subject.text.endsWith('s') && !subject.text.endsWith('ss') && !namesForLang.includes(subject.text)) {\n      const knownSingularSEndings = ['bus', 'gas', 'lens', 'plus', 'status', 'species', 'series', 'news', 'always', 'this', 'is', 'has', 'does', 'goes'];\n      if (!knownSingularSEndings.includes(subject.text.toLowerCase())) {\n        subject.isPlural = true;\n      }\n    }\n    subject.representativePronoun = subject.isPlural ? t.pronoun_they || \"they\" : namesForLang.includes(subject.text) ? Math.random() < 0.5 ? t.pronoun_he || \"he\" : t.pronoun_she || \"she\" : t.pronoun_it || \"it\";\n  } else if (allowCompound && potentialNouns.length >= 2 && typeRoll < 0.95) {\n    let noun1Raw = getRandomElement(potentialNouns);\n    let noun2Raw = getRandomElement(potentialNouns.filter(n => n !== noun1Raw));\n    if (!noun2Raw) noun2Raw = getRandomElement(namesForLang.filter(n => n !== noun1Raw)) || (potentialNouns.length > 0 ? potentialNouns[0] : t.noun_friends || \"friends\");\n    const noun1 = namesForLang.includes(noun1Raw) ? noun1Raw : noun1Raw.toLowerCase();\n    const noun2 = namesForLang.includes(noun2Raw) ? noun2Raw : noun2Raw.toLowerCase();\n    subject.text = `${noun1} ${t.conjunction_and || 'and'} ${noun2}`;\n    subject.type = \"noun_compound_and\";\n    subject.isPlural = true;\n    subject.representativePronoun = t.pronoun_they || \"they\";\n  } else {\n    const chosenPronoun = getRandomElement(availablePronouns) || t.pronoun_they || (language === 'COSYenglish' ? \"they\" : \"ils\");\n    subject.text = chosenPronoun;\n    subject.type = \"pronoun\";\n    const pluralPronouns = t.pluralPronounsList || ['we', 'they', 'you'];\n    subject.isPlural = pluralPronouns.includes(chosenPronoun.toLowerCase());\n    subject.representativePronoun = chosenPronoun.toLowerCase();\n  }\n  if (subject.type === \"noun\") {\n    subject.representativePronoun = subject.isPlural ? t.pronoun_they || \"they\" : namesForLang.includes(subject.text) ? Math.random() < 0.5 ? t.pronoun_he || \"he\" : t.pronoun_she || \"she\" : t.pronoun_it || \"it\";\n  }\n  return subject;\n}\nasync function selectObject(language, vocabularyList, subjectText = \"\") {\n  const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\n  const potentialObjects = vocabularyList.filter(v => typeof v === 'string' && v.length > 1 && v.toLowerCase() !== subjectText.toLowerCase());\n  if (potentialObjects.length === 0) {\n    return t.genericObjectFallback || \"something\";\n  }\n  const chosenObject = getRandomElement(potentialObjects);\n  const namesForLang = t.commonNames && t.commonNames.length > 0 ? t.commonNames : language === 'COSYenglish' ? COMMON_NAMES_EN : [];\n  return namesForLang.includes(chosenObject) ? chosenObject : chosenObject.toLowerCase();\n}\n\n/**\r\n * Processes raw verb data items to derive necessary fields like pronoun, form, verb,\r\n * full_sentence, and sentence_template. This mirrors the processing logic from the\r\n * old `loadVerbGrammar` function in `grammar.js`.\r\n * @param {Array<Object>} rawVerbItems - Array of verb items as loaded from JSON.\r\n * @param {string} language - The current COSYlanguage code.\r\n * @returns {Array<Object>} Processed verb items.\r\n */\nexport function processVerbData(rawVerbItems, language) {\n  const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\n  let processedVerbData = [];\n  let seenItems = new Set();\n  rawVerbItems.forEach(rawItem => {\n    let item = {\n      ...rawItem\n    };\n    let sPrompt = rawItem.prompt;\n    if (Array.isArray(sPrompt)) sPrompt = sPrompt.join('/');\n    sPrompt = sPrompt === null || sPrompt === undefined ? \"\" : String(sPrompt);\n    let sAnswer = rawItem.answer;\n    if (Array.isArray(sAnswer)) sAnswer = sAnswer.join('/');\n    sAnswer = sAnswer === null || sAnswer === undefined ? \"\" : String(sAnswer);\n    item.promptType = 'pronoun_verb_expects_form'; // Default\n\n    if (sPrompt && sAnswer) {\n      const commonPronouns = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'je', 'tu', 'il', 'elle', 'on', 'nous', 'vous', 'ils', 'elles', 'ich', 'du', 'er', 'sie', 'es', 'wir', 'ihr', 'io', 'tu', 'lui', 'lei', 'noi', 'voi', 'loro', 'yo', 'tú', 'él', 'ella', 'usted', 'nosotros', 'nosotras', 'vosotros', 'vosotras', 'ellos', 'ellas', 'ustedes', 'eu', 'tu', 'ele', 'ela', 'você', 'nós', 'vós', 'eles', 'elas', 'vocês', 'я', 'ты', 'он', 'она', 'оно', 'мы', 'вы', 'они', 'minä', 'sinä', 'hän'];\n      let langSpecificLength = 3; // Default pronoun max length for check\n      if (language === 'COSYfrançais' || language === 'COSYitaliano') langSpecificLength = 2;\n      const isPromptPronounLike = commonPronouns.includes(sPrompt.toLowerCase()) || sPrompt.length <= langSpecificLength;\n      if (isPromptPronounLike) {\n        item.pronoun = sPrompt;\n        item.form = sAnswer; // This is the conjugated verb form\n        item.promptType = 'pronoun_expects_form';\n      } else {\n        const isAnswerPronounLike = commonPronouns.includes(sAnswer.toLowerCase()) || sAnswer.length <= langSpecificLength || sAnswer.includes('/');\n        if (isAnswerPronounLike) {\n          item.form = sPrompt; // This is the conjugated verb form\n          item.pronoun = sAnswer;\n          item.promptType = 'form_expects_pronoun';\n        } else {\n          // Default assumption if neither looks like a pronoun\n          item.pronoun = sPrompt; // Assume prompt is pronoun-like\n          item.form = sAnswer; // Assume answer is verb form\n        }\n      }\n    } else {\n      // If prompt or answer is missing, try to assign directly\n      item.pronoun = sPrompt;\n      item.form = sAnswer;\n    }\n    if (!item.verb) {\n      // Infer verb if not present\n      let baseWordForVerbInference = item.form; // Usually the conjugated form helps infer infinitive\n      if (baseWordForVerbInference) {\n        const toBeForms = ['am', 'is', 'are', 'was', 'were', 'est', 'sont', 'être', 'es', 'son', 'ser', 'είμαι', 'είσαι', 'είναι', 'быть', 'был', 'была', 'было', 'были'];\n        const toHaveForms = ['have', 'has', 'had', 'a', 'ont', 'avoir', 'tiene', 'tienen', 'tener', 'tem', 'têm', 'ter', 'έχω', 'έχει', 'иметь', 'имел', 'имела'];\n        const infinitiveMarker = t.infinitiveMarker || (language === 'COSYenglish' ? 'to ' : '');\n        const verbToBe = t.verbToBe || 'to be';\n        const verbToHave = t.verbToHave || 'to have';\n        if (toBeForms.includes(baseWordForVerbInference.toLowerCase())) item.verb = verbToBe;else if (toHaveForms.includes(baseWordForVerbInference.toLowerCase())) item.verb = verbToHave;else {\n          // Basic inference for other verbs (language-specific rules would be better)\n          let potentialInfinitive = baseWordForVerbInference.toLowerCase();\n          if (language === 'COSYenglish') {\n            if (potentialInfinitive.endsWith('s') && !['is', 'was', 'has', 'does', 'goes'].includes(potentialInfinitive) && !potentialInfinitive.endsWith('ss')) {\n              potentialInfinitive = potentialInfinitive.slice(0, -1);\n            } else if (potentialInfinitive.endsWith('ed')) {\n              potentialInfinitive = potentialInfinitive.slice(0, -2);\n            } else if (potentialInfinitive.endsWith('ing')) {\n              potentialInfinitive = potentialInfinitive.slice(0, -3);\n            }\n          }\n          item.verb = `${infinitiveMarker}${potentialInfinitive}`;\n        }\n      }\n    }\n\n    // Ensure crucial fields are present\n    if (!item.pronoun || !item.verb || !item.form) {\n      // console.warn(\"Skipping verb item due to missing core fields:\", rawItem);\n      return; // Skips this iteration of forEach\n    }\n    if (!item.full_sentence) {\n      let objectPart = t.defaultAdjective || \"happy\";\n      if (item.verb && item.verb.toLowerCase() === (t.verbToHave || 'to have').toLowerCase()) objectPart = t.defaultNounWithArticle || (language === 'COSYenglish' ? \"a cat\" : t.defaultNoun || \"cat\");else if (item.verb && item.verb.toLowerCase() !== (t.verbToBe || 'to be').toLowerCase()) objectPart = t.defaultAdverb || \"well\";\n      item.full_sentence = `${item.pronoun} ${item.form} ${objectPart}.`;\n    }\n    if (!item.sentence_template) {\n      const formEscaped = escapeRegExp(item.form);\n      const formRegex = new RegExp(`\\\\b${formEscaped}\\\\b`, 'i');\n      item.sentence_template = item.full_sentence.replace(formRegex, \"___\");\n      if (!item.sentence_template.includes(\"___\")) {\n        // Fallback if regex replace failed\n        let parts = item.full_sentence.split(' ');\n        let formIndex = parts.findIndex(p => p.toLowerCase() === item.form.toLowerCase());\n        if (formIndex !== -1) {\n          parts[formIndex] = \"___\";\n          item.sentence_template = parts.join(' ');\n        } else {\n          // More robust fallback: place blank after pronoun if form not found\n          item.sentence_template = `${item.pronoun} ___ .`;\n        }\n      }\n    }\n    // Use a consistent key for uniqueness check\n    const stringifiedItemKey = JSON.stringify({\n      pronoun: item.pronoun,\n      verb: item.verb,\n      form: item.form,\n      promptType: item.promptType\n    });\n    if (!seenItems.has(stringifiedItemKey)) {\n      seenItems.add(stringifiedItemKey);\n      processedVerbData.push(item);\n    }\n  });\n  return processedVerbData;\n}\nexport async function generateGrammarExerciseSentence(language, days, allProcessedVerbData, dailyVocab) {\n  const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\n  if (!allProcessedVerbData || allProcessedVerbData.length === 0) {\n    console.error(\"generateGrammarExerciseSentence: No processed verb data provided for language \" + language);\n    return null;\n  }\n  let currentDailyVocab = dailyVocab;\n  if (!currentDailyVocab || currentDailyVocab.length === 0) {\n    // console.warn(`generateGrammarExerciseSentence: No daily vocabulary for ${language}. Fetching fallback.`);\n    // In a real scenario, TypeVerbExercise would fetch this. For the util, we assume it's passed or use very basic fallbacks.\n    const {\n      data: vocabWords\n    } = await loadVocabularyData(language, days); // Fetch if not provided\n    currentDailyVocab = vocabWords.length > 0 ? vocabWords : [t.genericNoun1 || \"book\", t.genericNoun2 || \"pen\", t.genericAdjective1 || \"interesting\"];\n  }\n  const sentencePatterns = [{\n    type: \"SVO\",\n    structure: [\"S\", \"V\", \"O\"],\n    needsAux: false,\n    isQuestion: false\n  }, {\n    type: \"SVNegO\",\n    structure: [\"S\", \"V(neg)\", \"O\"],\n    needsAux: true,\n    isQuestion: false\n  }, {\n    type: \"Q_AuxSVO\",\n    structure: [\"Aux\", \"S\", \"V_base\", \"O?\"],\n    needsAux: true,\n    isQuestion: true\n  }, {\n    type: \"Q_BeSVO\",\n    structure: [\"V_be\", \"S\", \"O?\"],\n    needsAux: false,\n    isQuestion: true\n  }];\n  let selectedPattern = getRandomElement(sentencePatterns);\n  if (!selectedPattern) return null;\n  const subjectDetails = await selectSubject(language, allProcessedVerbData, currentDailyVocab);\n  let objectText = await selectObject(language, currentDailyVocab, subjectDetails.text);\n  let verbInfo = null;\n  let attempts = 0;\n  const maxAttempts = 30;\n  while (attempts < maxAttempts && !verbInfo) {\n    const randomVerbEntry = getRandomElement(allProcessedVerbData);\n    if (!randomVerbEntry || !randomVerbEntry.verb || !randomVerbEntry.pronoun || !randomVerbEntry.form) {\n      attempts++;\n      continue;\n    }\n    const verbPronouns = randomVerbEntry.pronoun.toLowerCase().split('/');\n    const representativePronoun = subjectDetails.representativePronoun.toLowerCase();\n    if (verbPronouns.includes(representativePronoun)) {\n      let suitableForPattern = true;\n      if (selectedPattern.type === \"Q_BeSVO\" && randomVerbEntry.verb.toLowerCase() !== (t.verbToBe || 'to be').toLowerCase()) {\n        suitableForPattern = false;\n      } else if (selectedPattern.type === \"Q_AuxSVO\" && randomVerbEntry.verb.toLowerCase() === (t.verbToBe || 'to be').toLowerCase()) {\n        suitableForPattern = false;\n      }\n      if (suitableForPattern) {\n        verbInfo = {\n          base: randomVerbEntry.verb,\n          conjugated: randomVerbEntry.form,\n          isBeOrHave: randomVerbEntry.verb.toLowerCase() === (t.verbToBe || 'to be').toLowerCase() || randomVerbEntry.verb.toLowerCase() === (t.verbToHave || 'to have').toLowerCase(),\n          fullItem: randomVerbEntry\n        };\n        break;\n      }\n    }\n    attempts++;\n  }\n  if (!verbInfo) {\n    // Fallback: pick any verb and adjust subject\n    const anyVerbFromPool = getRandomElement(allProcessedVerbData);\n    if (anyVerbFromPool) {\n      verbInfo = {\n        base: anyVerbFromPool.verb,\n        conjugated: anyVerbFromPool.form,\n        isBeOrHave: anyVerbFromPool.verb.toLowerCase() === (t.verbToBe || 'to be').toLowerCase() || anyVerbFromPool.verb.toLowerCase() === (t.verbToHave || 'to have').toLowerCase(),\n        fullItem: anyVerbFromPool\n      };\n      subjectDetails.text = anyVerbFromPool.pronoun.split('/')[0];\n      subjectDetails.representativePronoun = subjectDetails.text.toLowerCase();\n      const pluralPronouns = t.pluralPronounsList || ['we', 'they', 'you'];\n      subjectDetails.isPlural = pluralPronouns.includes(subjectDetails.representativePronoun);\n    } else {\n      console.error(\"generateGrammarExerciseSentence: Could not find any verb even after fallback.\");\n      return null;\n    }\n  }\n  let sentenceComponents = [];\n  let S_final = subjectDetails.text;\n  let O_final = objectText;\n  if (selectedPattern.type === \"Q_BeSVO\" && language === 'COSYenglish') {\n    const namesForLangLower = (t.commonNames || COMMON_NAMES_EN).map(n => n.toLowerCase());\n    if (subjectDetails.type === \"noun\" && !namesForLangLower.includes(S_final.toLowerCase())) {\n      S_final = addIndefiniteArticle(S_final, language);\n    }\n    const isObjectLikelySimpleNounForArticle = (currentDailyVocab.map(w => w.toLowerCase()).includes(objectText.toLowerCase()) || (t.exampleNounsForArticle || [\"book\", \"cat\", \"pen\", \"apple\"]).includes(objectText.toLowerCase())) && objectText.split(' ').length === 1 && !namesForLangLower.includes(objectText.toLowerCase());\n    if (isObjectLikelySimpleNounForArticle) {\n      O_final = addIndefiniteArticle(objectText, language);\n    }\n  }\n  const V_conj = verbInfo.conjugated;\n  const V_base_inf = verbInfo.base.startsWith(t.infinitiveMarker || (language === 'COSYenglish' ? 'to ' : '')) ? verbInfo.base.substring((t.infinitiveMarker || (language === 'COSYenglish' ? 'to ' : '')).length) : verbInfo.base;\n  let aux = \"\";\n  if (language === 'COSYenglish') {\n    // Language-specific auxiliary logic\n    if (selectedPattern.type === \"SVNegO\") {\n      if (!verbInfo.isBeOrHave) {\n        // \"do not\" / \"does not\"\n        aux = subjectDetails.isPlural || ['i', 'you'].includes(subjectDetails.representativePronoun.toLowerCase()) ? \"do\" : \"does\";\n      } // For \"be/have\", negation is direct: \"is not\", \"has not\"\n    } else if (selectedPattern.type === \"Q_AuxSVO\") {\n      aux = subjectDetails.isPlural || ['i', 'you'].includes(subjectDetails.representativePronoun.toLowerCase()) ? \"Do\" : \"Does\";\n    }\n  }\n  // Simplified sentence construction based on pattern\n  // This part needs careful porting of the logic from grammar.js's generateSentenceForExercise\n  switch (selectedPattern.type) {\n    case \"SVO\":\n      sentenceComponents = [S_final, V_conj, O_final];\n      break;\n    case \"SVNegO\":\n      if (language === 'COSYenglish' && aux) {\n        // e.g. \"They do not like cats\"\n        sentenceComponents = [S_final, aux, t.negationParticle || \"not\", V_base_inf, O_final];\n      } else if (verbInfo.isBeOrHave) {\n        // e.g. \"He is not happy\"\n        sentenceComponents = [S_final, V_conj, t.negationParticle || \"not\", O_final];\n      } else {\n        // Non-english or verbs that don't use \"do\" aux for negation\n        sentenceComponents = [S_final, V_conj, t.negationParticle || \"not\", O_final]; // Fallback or other languages\n      }\n      break;\n    case \"Q_AuxSVO\":\n      // e.g. \"Do they like cats?\"\n      if (language === 'COSYenglish' && aux) {\n        sentenceComponents = [aux, S_final, V_base_inf, O_final];\n      } else {\n        // Fallback for non-english or if aux logic is different\n        sentenceComponents = [V_conj, S_final, O_final];\n      }\n      break;\n    case \"Q_BeSVO\":\n      // e.g. \"Is he happy?\"\n      sentenceComponents = [V_conj, S_final, O_final];\n      break;\n    default:\n      return null;\n  }\n  let finalCasedComponents = sentenceComponents.filter(c => c).map((word, index) => {\n    // filter out null/empty aux\n    if (typeof word !== 'string') return word;\n    const namesForLang = t.commonNames && t.commonNames.length > 0 ? t.commonNames : language === 'COSYenglish' ? COMMON_NAMES_EN : [];\n    if (namesForLang.includes(word)) return word;\n    if (language === 'COSYenglish' && word.toLowerCase() === 'i') return 'I';\n    return index === 0 ? capitalizeWord(word, true, language) : word;\n  });\n  const finalPunctuation = selectedPattern.isQuestion ? \"?\" : \".\";\n  let correctSentence = finalCasedComponents.join(\" \") + finalPunctuation;\n\n  // Determine what to blank out\n  let wordToBlankOriginal = '';\n  let indexOfBlankInCased = -1;\n  const blankTypeRoll = Math.random();\n  if (blankTypeRoll < 0.5 && V_conj) {\n    // Blank the main verb (conjugated or base)\n    wordToBlankOriginal = selectedPattern.type === \"SVNegO\" && language === 'COSYenglish' && aux || selectedPattern.type === \"Q_AuxSVO\" && language === 'COSYenglish' && aux ? V_base_inf : V_conj;\n  } else if (blankTypeRoll < 0.75 && subjectDetails.type !== \"pronoun\" && S_final) {\n    // Blank subject if not pronoun\n    wordToBlankOriginal = S_final;\n  } else if (O_final) {\n    // Blank object\n    wordToBlankOriginal = O_final;\n  } else if (V_conj) {\n    // Fallback to verb if object was blanked but missing\n    wordToBlankOriginal = selectedPattern.type === \"SVNegO\" && language === 'COSYenglish' && aux || selectedPattern.type === \"Q_AuxSVO\" && language === 'COSYenglish' && aux ? V_base_inf : V_conj;\n  } else {\n    // Ultimate fallback\n    wordToBlankOriginal = finalCasedComponents.length > 1 ? finalCasedComponents[1] : finalCasedComponents[0];\n  }\n\n  // Find the cased version of the word to blank\n  let tempSentenceForTemplate = [...finalCasedComponents];\n  const casedWordToBlank = finalCasedComponents.find(w => w.toLowerCase() === wordToBlankOriginal.toLowerCase());\n  if (casedWordToBlank) {\n    indexOfBlankInCased = finalCasedComponents.indexOf(casedWordToBlank);\n    tempSentenceForTemplate[indexOfBlankInCased] = \"___\";\n  } else if (finalCasedComponents.length > 0) {\n    // Fallback if exact cased match not found\n    indexOfBlankInCased = finalCasedComponents.length > 1 ? 1 : 0;\n    wordToBlankOriginal = finalCasedComponents[indexOfBlankInCased]; // update original to what's actually blanked\n    tempSentenceForTemplate[indexOfBlankInCased] = \"___\";\n  } else {\n    return {\n      questionPrompt: \"___\" + finalPunctuation,\n      answer: t.errorFallbackWord || \"error\",\n      correctSentence: t.errorFallbackWord + finalPunctuation\n    };\n  }\n  let sentenceTemplate = tempSentenceForTemplate.join(\" \") + finalPunctuation;\n  return {\n    questionPrompt: sentenceTemplate.trim(),\n    answer: wordToBlankOriginal.trim(),\n    // This should be the non-cased, original form intended for the blank\n    correctSentence: correctSentence.trim()\n    // For debugging or more complex hints:\n    // rawSubject: subjectDetails,\n    // rawVerb: verbInfo,\n    // rawObject: objectText,\n    // sentenceComponents: finalCasedComponents,\n  };\n}","map":{"version":3,"names":["shuffleArray","capitalizeWord","escapeRegExp","loadVocabularyData","currentTranslations","COSYenglish","defaultAdjective","defaultNounWithArticle","defaultNoun","defaultAdverb","infinitiveMarker","verbToBe","verbToHave","negationParticle","pronoun_they","pronoun_he","pronoun_she","pronoun_it","conjunction_and","commonNames","genericObjectFallback","pluralPronounsList","sentenceEndingAdjective","sentenceEndingAdverb","errorFallbackWord","setGrammarGeneratorTranslations","translations","COMMON_NAMES_EN","getRandomElement","arr","length","Math","floor","random","addIndefiniteArticle","nounStr","language","t","trim","trimmedNoun","articleRegex","test","lowerNoun","toLowerCase","pronounsAndSomeNames","map","n","includes","endsWith","knownSingularSEndings","firstLetter","charAt","vowels","exceptionsAn","exceptionsA","some","ex","startsWith","selectSubject","verbData","vocabularyList","allowCompound","typeRoll","subject","text","type","isPlural","representativePronoun","availablePronouns","Set","vd","pronoun","filter","p","simpleNouns","v","split","knownVerbForms","form","potentialNouns","has","namesForLang","chosenPronoun","pluralPronouns","singularPronouns","nounSourceRoll","chosenNoun","noun1Raw","noun2Raw","noun_friends","noun1","noun2","selectObject","subjectText","potentialObjects","chosenObject","processVerbData","rawVerbItems","processedVerbData","seenItems","forEach","rawItem","item","sPrompt","prompt","Array","isArray","join","undefined","String","sAnswer","answer","promptType","commonPronouns","langSpecificLength","isPromptPronounLike","isAnswerPronounLike","verb","baseWordForVerbInference","toBeForms","toHaveForms","potentialInfinitive","slice","full_sentence","objectPart","sentence_template","formEscaped","formRegex","RegExp","replace","parts","formIndex","findIndex","stringifiedItemKey","JSON","stringify","add","push","generateGrammarExerciseSentence","days","allProcessedVerbData","dailyVocab","console","error","currentDailyVocab","data","vocabWords","genericNoun1","genericNoun2","genericAdjective1","sentencePatterns","structure","needsAux","isQuestion","selectedPattern","subjectDetails","objectText","verbInfo","attempts","maxAttempts","randomVerbEntry","verbPronouns","suitableForPattern","base","conjugated","isBeOrHave","fullItem","anyVerbFromPool","sentenceComponents","S_final","O_final","namesForLangLower","isObjectLikelySimpleNounForArticle","w","exampleNounsForArticle","V_conj","V_base_inf","substring","aux","finalCasedComponents","c","word","index","finalPunctuation","correctSentence","wordToBlankOriginal","indexOfBlankInCased","blankTypeRoll","tempSentenceForTemplate","casedWordToBlank","find","indexOf","questionPrompt","sentenceTemplate"],"sources":["/workspaces/COSYlanguagesproject/src/utils/grammarSentenceGenerator.js"],"sourcesContent":["import { shuffleArray } from './arrayUtils';\r\nimport { capitalizeWord, escapeRegExp } from './stringUtils';\r\nimport { loadVocabularyData } from './exerciseDataService'; // For fetching vocabulary for objects\r\n\r\n// This will hold translations, to be populated ideally by I18nContext or similar\r\n// For now, using a simple placeholder. In a real app, this should be managed by an i18n solution.\r\nlet currentTranslations = {\r\n    COSYenglish: {\r\n        defaultAdjective: \"happy\",\r\n        defaultNounWithArticle: \"a cat\",\r\n        defaultNoun: \"cat\",\r\n        defaultAdverb: \"well\",\r\n        infinitiveMarker: \"to \",\r\n        verbToBe: \"to be\",\r\n        verbToHave: \"to have\",\r\n        negationParticle: \"not\",\r\n        pronoun_they: \"they\",\r\n        pronoun_he: \"he\",\r\n        pronoun_she: \"she\",\r\n        pronoun_it: \"it\",\r\n        conjunction_and: \"and\",\r\n        commonNames: [\"Alex\", \"Maria\", \"Sam\", \"Lee\", \"Jordan\", \"Taylor\", \"Chris\", \"Pat\"],\r\n        genericObjectFallback: \"something\",\r\n        pluralPronounsList: ['we', 'they', 'you'], // Simplified for example\r\n        sentenceEndingAdjective: \"happy.\",\r\n        sentenceEndingAdverb: \"well.\",\r\n        errorFallbackWord: \"error\",\r\n    }\r\n};\r\n\r\n// Function to update translations if needed (e.g., from context)\r\nexport function setGrammarGeneratorTranslations(translations) {\r\n    currentTranslations = translations;\r\n}\r\n\r\nconst COMMON_NAMES_EN = [\"Alex\", \"Maria\", \"Sam\", \"Lee\", \"Jordan\", \"Taylor\", \"Chris\", \"Pat\"];\r\n\r\nfunction getRandomElement(arr) {\r\n    if (!arr || arr.length === 0) return null;\r\n    return arr[Math.floor(Math.random() * arr.length)];\r\n}\r\n\r\n// Adapted from old grammar.js - specific to English for now\r\nfunction addIndefiniteArticle(nounStr, language) {\r\n    const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\r\n    if (language !== 'COSYenglish' || typeof nounStr !== 'string' || nounStr.trim() === '') {\r\n        return nounStr;\r\n    }\r\n    const trimmedNoun = nounStr.trim();\r\n    const articleRegex = /^(a|an|the)\\s/i;\r\n    if (articleRegex.test(trimmedNoun)) { return nounStr; }\r\n    const lowerNoun = trimmedNoun.toLowerCase();\r\n    const pronounsAndSomeNames = ['i', 'you', 'he', 'she', 'it', 'we', 'they', ...(t.commonNames || COMMON_NAMES_EN).map(n => n.toLowerCase())];\r\n    if (pronounsAndSomeNames.includes(lowerNoun)) { return nounStr; }\r\n    if (trimmedNoun.endsWith('s') && !trimmedNoun.endsWith('ss')) {\r\n        const knownSingularSEndings = ['bus', 'gas', 'lens', 'plus', 'status', 'species', 'series', 'news'];\r\n        if (!knownSingularSEndings.includes(lowerNoun)) { return nounStr; }\r\n    }\r\n    const firstLetter = trimmedNoun.charAt(0).toLowerCase();\r\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\r\n    const exceptionsAn = ['hour', 'honest', 'honor', 'heir'];\r\n    const exceptionsA = ['user', 'university', 'uniform', 'european', 'one', 'unit'];\r\n    if (exceptionsAn.some(ex => lowerNoun.startsWith(ex))) return `an ${trimmedNoun}`;\r\n    if (exceptionsA.some(ex => lowerNoun.startsWith(ex))) return `a ${trimmedNoun}`;\r\n    if (vowels.includes(firstLetter)) { return `an ${trimmedNoun}`; }\r\n    else { return `a ${trimmedNoun}`; }\r\n}\r\n\r\nasync function selectSubject(language, verbData, vocabularyList, allowCompound = true) {\r\n    const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\r\n    const typeRoll = Math.random();\r\n    let subject = { text: \"it\", type: \"pronoun\", isPlural: false, representativePronoun: \"it\" };\r\n\r\n    const availablePronouns = [...new Set(verbData.map(vd => vd.pronoun).filter(p => p && !p.includes('/')))];\r\n    const simpleNouns = vocabularyList.filter(v => typeof v === 'string' && v.length > 1 && v.split(' ').length === 1);\r\n    const knownVerbForms = new Set(verbData.map(vd => vd.form.toLowerCase()));\r\n    const potentialNouns = simpleNouns.filter(n => !knownVerbForms.has(n.toLowerCase()));\r\n    let namesForLang = (t.commonNames && t.commonNames.length > 0) ? t.commonNames : (language === 'COSYenglish' ? COMMON_NAMES_EN : []);\r\n\r\n    if (typeRoll < 0.4 && availablePronouns.length > 0) {\r\n        const chosenPronoun = getRandomElement(availablePronouns);\r\n        subject.text = chosenPronoun;\r\n        subject.type = \"pronoun\";\r\n        const pluralPronouns = t.pluralPronounsList || ['we', 'they', 'you', 'nous', 'vous', 'ils', 'elles', 'wir', 'ihr', 'sie', 'voi', 'loro', 'nosotros', 'vosotros', 'ellos', 'ellas', 'ustedes', 'nós', 'vós', 'eles', 'elas', 'мы', 'вы', 'они', 'me', 'te', 'he'];\r\n        const singularPronouns = ['i', 'he', 'she', 'it', 'je', 'tu', 'il', 'elle', 'on', 'ich', 'du', 'er', 'es', 'io', 'lui', 'lei', 'yo', 'tú', 'él', 'ella', 'usted', 'eu', 'ele', 'ela', 'você', 'я', 'ты', 'он', 'она', 'оно', 'minä', 'sinä', 'hän'];\r\n        if (pluralPronouns.includes(chosenPronoun?.toLowerCase())) subject.isPlural = true;\r\n        if (singularPronouns.includes(chosenPronoun?.toLowerCase())) subject.isPlural = false;\r\n        subject.representativePronoun = chosenPronoun.toLowerCase();\r\n    } else if (typeRoll < 0.8 && (potentialNouns.length > 0 || namesForLang.length > 0)) {\r\n        const nounSourceRoll = Math.random();\r\n        let chosenNoun;\r\n        if (nounSourceRoll < 0.7 && potentialNouns.length > 0) {\r\n            chosenNoun = getRandomElement(potentialNouns);\r\n        } else if (namesForLang.length > 0) {\r\n            chosenNoun = getRandomElement(namesForLang);\r\n        } else {\r\n            chosenNoun = getRandomElement(potentialNouns);\r\n        }\r\n        subject.text = namesForLang.includes(chosenNoun) ? chosenNoun : chosenNoun.toLowerCase();\r\n        subject.type = \"noun\";\r\n        subject.isPlural = false;\r\n        if (subject.text.endsWith('s') && !subject.text.endsWith('ss') && !namesForLang.includes(subject.text)) {\r\n            const knownSingularSEndings = ['bus', 'gas', 'lens', 'plus', 'status', 'species', 'series', 'news', 'always', 'this', 'is', 'has', 'does', 'goes'];\r\n            if (!knownSingularSEndings.includes(subject.text.toLowerCase())) {\r\n                subject.isPlural = true;\r\n            }\r\n        }\r\n        subject.representativePronoun = subject.isPlural ? (t.pronoun_they || \"they\") : (namesForLang.includes(subject.text) ? (Math.random() < 0.5 ? (t.pronoun_he || \"he\") : (t.pronoun_she || \"she\")) : (t.pronoun_it || \"it\"));\r\n    } else if (allowCompound && potentialNouns.length >= 2 && typeRoll < 0.95) {\r\n        let noun1Raw = getRandomElement(potentialNouns);\r\n        let noun2Raw = getRandomElement(potentialNouns.filter(n => n !== noun1Raw));\r\n        if (!noun2Raw) noun2Raw = getRandomElement(namesForLang.filter(n => n !== noun1Raw)) || (potentialNouns.length > 0 ? potentialNouns[0] : (t.noun_friends || \"friends\"));\r\n        const noun1 = namesForLang.includes(noun1Raw) ? noun1Raw : noun1Raw.toLowerCase();\r\n        const noun2 = namesForLang.includes(noun2Raw) ? noun2Raw : noun2Raw.toLowerCase();\r\n        subject.text = `${noun1} ${t.conjunction_and || 'and'} ${noun2}`;\r\n        subject.type = \"noun_compound_and\";\r\n        subject.isPlural = true;\r\n        subject.representativePronoun = (t.pronoun_they || \"they\");\r\n    } else {\r\n        const chosenPronoun = getRandomElement(availablePronouns) || (t.pronoun_they || (language === 'COSYenglish' ? \"they\" : \"ils\"));\r\n        subject.text = chosenPronoun;\r\n        subject.type = \"pronoun\";\r\n        const pluralPronouns = t.pluralPronounsList || ['we', 'they', 'you'];\r\n        subject.isPlural = pluralPronouns.includes(chosenPronoun.toLowerCase());\r\n        subject.representativePronoun = chosenPronoun.toLowerCase();\r\n    }\r\n    if (subject.type === \"noun\") {\r\n         subject.representativePronoun = subject.isPlural ? (t.pronoun_they || \"they\") : (namesForLang.includes(subject.text) ? (Math.random() < 0.5 ? (t.pronoun_he || \"he\") : (t.pronoun_she || \"she\")) : (t.pronoun_it || \"it\"));\r\n    }\r\n    return subject;\r\n}\r\n\r\nasync function selectObject(language, vocabularyList, subjectText = \"\") {\r\n    const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\r\n    const potentialObjects = vocabularyList.filter(v => typeof v === 'string' && v.length > 1 && v.toLowerCase() !== subjectText.toLowerCase());\r\n    if (potentialObjects.length === 0) {\r\n        return t.genericObjectFallback || \"something\";\r\n    }\r\n    const chosenObject = getRandomElement(potentialObjects);\r\n    const namesForLang = (t.commonNames && t.commonNames.length > 0) ? t.commonNames : (language === 'COSYenglish' ? COMMON_NAMES_EN : []);\r\n    return namesForLang.includes(chosenObject) ? chosenObject : chosenObject.toLowerCase();\r\n}\r\n\r\n\r\n/**\r\n * Processes raw verb data items to derive necessary fields like pronoun, form, verb,\r\n * full_sentence, and sentence_template. This mirrors the processing logic from the\r\n * old `loadVerbGrammar` function in `grammar.js`.\r\n * @param {Array<Object>} rawVerbItems - Array of verb items as loaded from JSON.\r\n * @param {string} language - The current COSYlanguage code.\r\n * @returns {Array<Object>} Processed verb items.\r\n */\r\nexport function processVerbData(rawVerbItems, language) {\r\n    const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\r\n    let processedVerbData = [];\r\n    let seenItems = new Set();\r\n\r\n    rawVerbItems.forEach(rawItem => {\r\n        let item = { ...rawItem };\r\n        let sPrompt = rawItem.prompt;\r\n        if (Array.isArray(sPrompt)) sPrompt = sPrompt.join('/');\r\n        sPrompt = (sPrompt === null || sPrompt === undefined) ? \"\" : String(sPrompt);\r\n\r\n        let sAnswer = rawItem.answer;\r\n        if (Array.isArray(sAnswer)) sAnswer = sAnswer.join('/');\r\n        sAnswer = (sAnswer === null || sAnswer === undefined) ? \"\" : String(sAnswer);\r\n        \r\n        item.promptType = 'pronoun_verb_expects_form'; // Default\r\n\r\n        if (sPrompt && sAnswer) {\r\n            const commonPronouns = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'je', 'tu', 'il', 'elle', 'on', 'nous', 'vous', 'ils', 'elles', 'ich', 'du', 'er', 'sie', 'es', 'wir', 'ihr', 'io', 'tu', 'lui', 'lei', 'noi', 'voi', 'loro', 'yo', 'tú', 'él', 'ella', 'usted', 'nosotros', 'nosotras', 'vosotros', 'vosotras', 'ellos', 'ellas', 'ustedes', 'eu', 'tu', 'ele', 'ela', 'você', 'nós', 'vós', 'eles', 'elas', 'vocês', 'я', 'ты', 'он', 'она', 'оно', 'мы', 'вы', 'они', 'minä', 'sinä', 'hän'];\r\n            let langSpecificLength = 3; // Default pronoun max length for check\r\n            if (language === 'COSYfrançais' || language === 'COSYitaliano') langSpecificLength = 2;\r\n            \r\n            const isPromptPronounLike = commonPronouns.includes(sPrompt.toLowerCase()) || sPrompt.length <= langSpecificLength;\r\n\r\n            if (isPromptPronounLike) {\r\n                item.pronoun = sPrompt;\r\n                item.form = sAnswer; // This is the conjugated verb form\r\n                item.promptType = 'pronoun_expects_form';\r\n            } else {\r\n                const isAnswerPronounLike = commonPronouns.includes(sAnswer.toLowerCase()) || sAnswer.length <= langSpecificLength || sAnswer.includes('/');\r\n                if (isAnswerPronounLike) {\r\n                    item.form = sPrompt; // This is the conjugated verb form\r\n                    item.pronoun = sAnswer;\r\n                    item.promptType = 'form_expects_pronoun';\r\n                } else { \r\n                    // Default assumption if neither looks like a pronoun\r\n                    item.pronoun = sPrompt; // Assume prompt is pronoun-like\r\n                    item.form = sAnswer;   // Assume answer is verb form\r\n                }\r\n            }\r\n        } else { // If prompt or answer is missing, try to assign directly\r\n            item.pronoun = sPrompt;\r\n            item.form = sAnswer;\r\n        }\r\n\r\n        if (!item.verb) { // Infer verb if not present\r\n            let baseWordForVerbInference = item.form; // Usually the conjugated form helps infer infinitive\r\n            if (baseWordForVerbInference) {\r\n                const toBeForms = ['am', 'is', 'are', 'was', 'were', 'est', 'sont', 'être', 'es', 'son', 'ser', 'είμαι', 'είσαι', 'είναι', 'быть', 'был', 'была', 'было', 'были'];\r\n                const toHaveForms = ['have', 'has', 'had', 'a', 'ont', 'avoir', 'tiene', 'tienen', 'tener', 'tem', 'têm', 'ter', 'έχω', 'έχει', 'иметь', 'имел', 'имела'];\r\n                const infinitiveMarker = t.infinitiveMarker || (language === 'COSYenglish' ? 'to ' : '');\r\n                const verbToBe = t.verbToBe || 'to be';\r\n                const verbToHave = t.verbToHave || 'to have';\r\n\r\n                if (toBeForms.includes(baseWordForVerbInference.toLowerCase())) item.verb = verbToBe;\r\n                else if (toHaveForms.includes(baseWordForVerbInference.toLowerCase())) item.verb = verbToHave;\r\n                else { // Basic inference for other verbs (language-specific rules would be better)\r\n                    let potentialInfinitive = baseWordForVerbInference.toLowerCase();\r\n                    if (language === 'COSYenglish') {\r\n                        if (potentialInfinitive.endsWith('s') && !['is', 'was', 'has', 'does', 'goes'].includes(potentialInfinitive) && !potentialInfinitive.endsWith('ss')) {\r\n                           potentialInfinitive = potentialInfinitive.slice(0, -1);\r\n                        } else if (potentialInfinitive.endsWith('ed')) {\r\n                           potentialInfinitive = potentialInfinitive.slice(0, -2);\r\n                        } else if (potentialInfinitive.endsWith('ing')) {\r\n                           potentialInfinitive = potentialInfinitive.slice(0, -3);\r\n                        }\r\n                    }\r\n                    item.verb = `${infinitiveMarker}${potentialInfinitive}`;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Ensure crucial fields are present\r\n        if (!item.pronoun || !item.verb || !item.form) {\r\n            // console.warn(\"Skipping verb item due to missing core fields:\", rawItem);\r\n            return; // Skips this iteration of forEach\r\n        }\r\n        \r\n        if (!item.full_sentence) {\r\n            let objectPart = t.defaultAdjective || \"happy\";\r\n            if (item.verb && (item.verb.toLowerCase() === (t.verbToHave || 'to have').toLowerCase())) objectPart = t.defaultNounWithArticle || (language === 'COSYenglish' ? \"a cat\" : (t.defaultNoun || \"cat\"));\r\n            else if (item.verb && (item.verb.toLowerCase() !== (t.verbToBe || 'to be').toLowerCase())) objectPart = t.defaultAdverb || \"well\";\r\n            item.full_sentence = `${item.pronoun} ${item.form} ${objectPart}.`;\r\n        }\r\n\r\n        if (!item.sentence_template) {\r\n             const formEscaped = escapeRegExp(item.form);\r\n             const formRegex = new RegExp(`\\\\b${formEscaped}\\\\b`, 'i');\r\n             item.sentence_template = item.full_sentence.replace(formRegex, \"___\");\r\n             if (!item.sentence_template.includes(\"___\")) { // Fallback if regex replace failed\r\n                let parts = item.full_sentence.split(' ');\r\n                let formIndex = parts.findIndex(p => p.toLowerCase() === item.form.toLowerCase());\r\n                if (formIndex !== -1) {\r\n                    parts[formIndex] = \"___\";\r\n                    item.sentence_template = parts.join(' ');\r\n                } else { \r\n                    // More robust fallback: place blank after pronoun if form not found\r\n                    item.sentence_template = `${item.pronoun} ___ .`; \r\n                }\r\n             }\r\n        }\r\n        // Use a consistent key for uniqueness check\r\n        const stringifiedItemKey = JSON.stringify({pronoun: item.pronoun, verb: item.verb, form: item.form, promptType: item.promptType});\r\n        if (!seenItems.has(stringifiedItemKey)) {\r\n            seenItems.add(stringifiedItemKey);\r\n            processedVerbData.push(item); \r\n        }\r\n    });\r\n    return processedVerbData;\r\n}\r\n\r\n\r\nexport async function generateGrammarExerciseSentence(language, days, allProcessedVerbData, dailyVocab) {\r\n    const t = currentTranslations[language] || currentTranslations.COSYenglish || {};\r\n    if (!allProcessedVerbData || allProcessedVerbData.length === 0) {\r\n        console.error(\"generateGrammarExerciseSentence: No processed verb data provided for language \" + language);\r\n        return null;\r\n    }\r\n    \r\n    let currentDailyVocab = dailyVocab;\r\n    if (!currentDailyVocab || currentDailyVocab.length === 0) {\r\n        // console.warn(`generateGrammarExerciseSentence: No daily vocabulary for ${language}. Fetching fallback.`);\r\n        // In a real scenario, TypeVerbExercise would fetch this. For the util, we assume it's passed or use very basic fallbacks.\r\n        const {data: vocabWords } = await loadVocabularyData(language, days); // Fetch if not provided\r\n        currentDailyVocab = vocabWords.length > 0 ? vocabWords : [t.genericNoun1 || \"book\", t.genericNoun2 || \"pen\", t.genericAdjective1 || \"interesting\"];\r\n    }\r\n\r\n    const sentencePatterns = [\r\n        { type: \"SVO\", structure: [\"S\", \"V\", \"O\"], needsAux: false, isQuestion: false },\r\n        { type: \"SVNegO\", structure: [\"S\", \"V(neg)\", \"O\"], needsAux: true, isQuestion: false },\r\n        { type: \"Q_AuxSVO\", structure: [\"Aux\", \"S\", \"V_base\", \"O?\"], needsAux: true, isQuestion: true },\r\n        { type: \"Q_BeSVO\", structure: [\"V_be\", \"S\", \"O?\"], needsAux: false, isQuestion: true }\r\n    ];\r\n\r\n    let selectedPattern = getRandomElement(sentencePatterns);\r\n    if (!selectedPattern) return null;\r\n\r\n    const subjectDetails = await selectSubject(language, allProcessedVerbData, currentDailyVocab);\r\n    let objectText = await selectObject(language, currentDailyVocab, subjectDetails.text);\r\n\r\n    let verbInfo = null;\r\n    let attempts = 0;\r\n    const maxAttempts = 30;\r\n\r\n    while (attempts < maxAttempts && !verbInfo) {\r\n        const randomVerbEntry = getRandomElement(allProcessedVerbData);\r\n        if (!randomVerbEntry || !randomVerbEntry.verb || !randomVerbEntry.pronoun || !randomVerbEntry.form) {\r\n            attempts++; continue;\r\n        }\r\n        const verbPronouns = randomVerbEntry.pronoun.toLowerCase().split('/');\r\n        const representativePronoun = subjectDetails.representativePronoun.toLowerCase();\r\n\r\n        if (verbPronouns.includes(representativePronoun)) {\r\n            let suitableForPattern = true;\r\n            if (selectedPattern.type === \"Q_BeSVO\" && randomVerbEntry.verb.toLowerCase() !== (t.verbToBe || 'to be').toLowerCase()) {\r\n                suitableForPattern = false;\r\n            } else if (selectedPattern.type === \"Q_AuxSVO\" && randomVerbEntry.verb.toLowerCase() === (t.verbToBe || 'to be').toLowerCase()) {\r\n                suitableForPattern = false;\r\n            }\r\n            if (suitableForPattern) {\r\n                verbInfo = { base: randomVerbEntry.verb, conjugated: randomVerbEntry.form, isBeOrHave: randomVerbEntry.verb.toLowerCase() === (t.verbToBe || 'to be').toLowerCase() || randomVerbEntry.verb.toLowerCase() === (t.verbToHave || 'to have').toLowerCase(), fullItem: randomVerbEntry };\r\n                break;\r\n            }\r\n        }\r\n        attempts++;\r\n    }\r\n    \r\n    if (!verbInfo) { // Fallback: pick any verb and adjust subject\r\n        const anyVerbFromPool = getRandomElement(allProcessedVerbData);\r\n        if (anyVerbFromPool) {\r\n            verbInfo = { base: anyVerbFromPool.verb, conjugated: anyVerbFromPool.form, isBeOrHave: anyVerbFromPool.verb.toLowerCase() === (t.verbToBe || 'to be').toLowerCase() || anyVerbFromPool.verb.toLowerCase() === (t.verbToHave || 'to have').toLowerCase(), fullItem: anyVerbFromPool };\r\n            subjectDetails.text = anyVerbFromPool.pronoun.split('/')[0];\r\n            subjectDetails.representativePronoun = subjectDetails.text.toLowerCase();\r\n            const pluralPronouns = t.pluralPronounsList || ['we', 'they', 'you'];\r\n            subjectDetails.isPlural = pluralPronouns.includes(subjectDetails.representativePronoun);\r\n        } else {\r\n            console.error(\"generateGrammarExerciseSentence: Could not find any verb even after fallback.\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    let sentenceComponents = [];\r\n    let S_final = subjectDetails.text;\r\n    let O_final = objectText;\r\n\r\n    if (selectedPattern.type === \"Q_BeSVO\" && language === 'COSYenglish') {\r\n        const namesForLangLower = ((t.commonNames || COMMON_NAMES_EN).map(n => n.toLowerCase()));\r\n        if (subjectDetails.type === \"noun\" && !namesForLangLower.includes(S_final.toLowerCase())) {\r\n            S_final = addIndefiniteArticle(S_final, language);\r\n        }\r\n        const isObjectLikelySimpleNounForArticle = (currentDailyVocab.map(w => w.toLowerCase()).includes(objectText.toLowerCase()) || (t.exampleNounsForArticle || [\"book\", \"cat\", \"pen\", \"apple\"]).includes(objectText.toLowerCase())) && objectText.split(' ').length === 1 && !namesForLangLower.includes(objectText.toLowerCase());\r\n        if (isObjectLikelySimpleNounForArticle) {\r\n            O_final = addIndefiniteArticle(objectText, language);\r\n        }\r\n    }\r\n    \r\n    const V_conj = verbInfo.conjugated;\r\n    const V_base_inf = verbInfo.base.startsWith(t.infinitiveMarker || (language === 'COSYenglish' ? 'to ' : '')) ? verbInfo.base.substring((t.infinitiveMarker || (language === 'COSYenglish' ? 'to ' : '')).length) : verbInfo.base;\r\n    let aux = \"\";\r\n\r\n    if (language === 'COSYenglish') { // Language-specific auxiliary logic\r\n        if (selectedPattern.type === \"SVNegO\") {\r\n            if (!verbInfo.isBeOrHave) { // \"do not\" / \"does not\"\r\n                aux = subjectDetails.isPlural || ['i', 'you'].includes(subjectDetails.representativePronoun.toLowerCase()) ? \"do\" : \"does\";\r\n            } // For \"be/have\", negation is direct: \"is not\", \"has not\"\r\n        } else if (selectedPattern.type === \"Q_AuxSVO\") {\r\n            aux = subjectDetails.isPlural || ['i', 'you'].includes(subjectDetails.representativePronoun.toLowerCase()) ? \"Do\" : \"Does\";\r\n        }\r\n    }\r\n    // Simplified sentence construction based on pattern\r\n    // This part needs careful porting of the logic from grammar.js's generateSentenceForExercise\r\n    switch (selectedPattern.type) {\r\n        case \"SVO\":\r\n            sentenceComponents = [S_final, V_conj, O_final];\r\n            break;\r\n        case \"SVNegO\":\r\n            if (language === 'COSYenglish' && aux) { // e.g. \"They do not like cats\"\r\n                sentenceComponents = [S_final, aux, (t.negationParticle || \"not\"), V_base_inf, O_final];\r\n            } else if (verbInfo.isBeOrHave) { // e.g. \"He is not happy\"\r\n                 sentenceComponents = [S_final, V_conj, (t.negationParticle || \"not\"), O_final];\r\n            } else { // Non-english or verbs that don't use \"do\" aux for negation\r\n                sentenceComponents = [S_final, V_conj, (t.negationParticle || \"not\"), O_final]; // Fallback or other languages\r\n            }\r\n            break;\r\n        case \"Q_AuxSVO\": // e.g. \"Do they like cats?\"\r\n            if (language === 'COSYenglish' && aux) {\r\n                sentenceComponents = [aux, S_final, V_base_inf, O_final];\r\n            } else { // Fallback for non-english or if aux logic is different\r\n                sentenceComponents = [V_conj, S_final, O_final]; \r\n            }\r\n            break;\r\n        case \"Q_BeSVO\": // e.g. \"Is he happy?\"\r\n            sentenceComponents = [V_conj, S_final, O_final];\r\n            break;\r\n        default: return null;\r\n    }\r\n\r\n    let finalCasedComponents = sentenceComponents.filter(c => c).map((word, index) => { // filter out null/empty aux\r\n        if (typeof word !== 'string') return word;\r\n        const namesForLang = (t.commonNames && t.commonNames.length > 0) ? t.commonNames : (language === 'COSYenglish' ? COMMON_NAMES_EN : []);\r\n        if (namesForLang.includes(word)) return word;\r\n        if (language === 'COSYenglish' && word.toLowerCase() === 'i') return 'I';\r\n        return (index === 0) ? capitalizeWord(word, true, language) : word;\r\n    });\r\n\r\n    const finalPunctuation = selectedPattern.isQuestion ? \"?\" : \".\";\r\n    let correctSentence = finalCasedComponents.join(\" \") + finalPunctuation;\r\n    \r\n    // Determine what to blank out\r\n    let wordToBlankOriginal = '';\r\n    let indexOfBlankInCased = -1;\r\n    const blankTypeRoll = Math.random();\r\n\r\n    if (blankTypeRoll < 0.5 && V_conj) { // Blank the main verb (conjugated or base)\r\n        wordToBlankOriginal = (selectedPattern.type === \"SVNegO\" && language === 'COSYenglish' && aux) || (selectedPattern.type === \"Q_AuxSVO\" && language === 'COSYenglish' && aux) ? V_base_inf : V_conj;\r\n    } else if (blankTypeRoll < 0.75 && subjectDetails.type !== \"pronoun\" && S_final) { // Blank subject if not pronoun\r\n        wordToBlankOriginal = S_final;\r\n    } else if (O_final) { // Blank object\r\n        wordToBlankOriginal = O_final;\r\n    } else if (V_conj) { // Fallback to verb if object was blanked but missing\r\n        wordToBlankOriginal = (selectedPattern.type === \"SVNegO\" && language === 'COSYenglish' && aux) || (selectedPattern.type === \"Q_AuxSVO\" && language === 'COSYenglish' && aux) ? V_base_inf : V_conj;\r\n    } else { // Ultimate fallback\r\n        wordToBlankOriginal = finalCasedComponents.length > 1 ? finalCasedComponents[1] : finalCasedComponents[0];\r\n    }\r\n    \r\n    // Find the cased version of the word to blank\r\n    let tempSentenceForTemplate = [...finalCasedComponents];\r\n    const casedWordToBlank = finalCasedComponents.find(w => w.toLowerCase() === wordToBlankOriginal.toLowerCase());\r\n    \r\n    if(casedWordToBlank){\r\n        indexOfBlankInCased = finalCasedComponents.indexOf(casedWordToBlank);\r\n        tempSentenceForTemplate[indexOfBlankInCased] = \"___\";\r\n    } else if (finalCasedComponents.length > 0) { // Fallback if exact cased match not found\r\n        indexOfBlankInCased = finalCasedComponents.length > 1 ? 1 : 0;\r\n        wordToBlankOriginal = finalCasedComponents[indexOfBlankInCased]; // update original to what's actually blanked\r\n        tempSentenceForTemplate[indexOfBlankInCased] = \"___\";\r\n    } else {\r\n        return { questionPrompt: \"___\" + finalPunctuation, answer: t.errorFallbackWord || \"error\", correctSentence: t.errorFallbackWord + finalPunctuation };\r\n    }\r\n\r\n    let sentenceTemplate = tempSentenceForTemplate.join(\" \") + finalPunctuation;\r\n\r\n    return {\r\n        questionPrompt: sentenceTemplate.trim(),\r\n        answer: wordToBlankOriginal.trim(), // This should be the non-cased, original form intended for the blank\r\n        correctSentence: correctSentence.trim(),\r\n        // For debugging or more complex hints:\r\n        // rawSubject: subjectDetails,\r\n        // rawVerb: verbInfo,\r\n        // rawObject: objectText,\r\n        // sentenceComponents: finalCasedComponents,\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}