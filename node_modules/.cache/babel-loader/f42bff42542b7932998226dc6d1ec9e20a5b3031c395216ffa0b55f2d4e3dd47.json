{"ast":null,"code":"/**\r\n * Shuffles an array in place and returns a new shuffled array.\r\n * @param {Array} array - The array to shuffle.\r\n * @returns {Array} A new array with the elements randomly shuffled.\r\n */export function shuffleArray(array){const newArray=[...array];for(let i=newArray.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[newArray[i],newArray[j]]=[newArray[j],newArray[i]];}return newArray;}/**\r\n * Selects a random item from an array of items, where each item has a weight.\r\n * @param {Array<{item: any, weight: number}>} itemsWithWeights - An array of objects,\r\n * each with an 'item' and its 'weight'.\r\n * @returns {any|null} The selected item, or null if the input is invalid or empty.\r\n */export function getWeightedRandomItem(itemsWithWeights){if(!itemsWithWeights||itemsWithWeights.length===0){return null;}const totalWeight=itemsWithWeights.reduce((sum,entry)=>sum+(entry.weight||0),0);if(totalWeight<=0){// If total weight is 0 (e.g., all weights are 0 or negative), fall back to uniform random selection.\nconst originalItems=itemsWithWeights.map(iw=>iw.item);return originalItems.length>0?originalItems[Math.floor(Math.random()*originalItems.length)]:null;}let randomValue=Math.random()*totalWeight;for(let i=0;i<itemsWithWeights.length;i++){if(randomValue<(itemsWithWeights[i].weight||0)){return itemsWithWeights[i].item;}randomValue-=itemsWithWeights[i].weight||0;}// Fallback in case of rounding errors or unexpected scenarios, though theoretically should be covered.\nconst originalItems=itemsWithWeights.map(iw=>iw.item);return originalItems.length>0?originalItems[Math.floor(Math.random()*originalItems.length)]:null;}","map":{"version":3,"names":["shuffleArray","array","newArray","i","length","j","Math","floor","random","getWeightedRandomItem","itemsWithWeights","totalWeight","reduce","sum","entry","weight","originalItems","map","iw","item","randomValue"],"sources":["/workspaces/COSYlanguagesproject/src/utils/arrayUtils.js"],"sourcesContent":["/**\r\n * Shuffles an array in place and returns a new shuffled array.\r\n * @param {Array} array - The array to shuffle.\r\n * @returns {Array} A new array with the elements randomly shuffled.\r\n */\r\nexport function shuffleArray(array) {\r\n  const newArray = [...array];\r\n  for (let i = newArray.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\r\n  }\r\n  return newArray;\r\n}\r\n\r\n/**\r\n * Selects a random item from an array of items, where each item has a weight.\r\n * @param {Array<{item: any, weight: number}>} itemsWithWeights - An array of objects,\r\n * each with an 'item' and its 'weight'.\r\n * @returns {any|null} The selected item, or null if the input is invalid or empty.\r\n */\r\nexport function getWeightedRandomItem(itemsWithWeights) {\r\n  if (!itemsWithWeights || itemsWithWeights.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const totalWeight = itemsWithWeights.reduce((sum, entry) => sum + (entry.weight || 0), 0);\r\n  if (totalWeight <= 0) {\r\n    // If total weight is 0 (e.g., all weights are 0 or negative), fall back to uniform random selection.\r\n    const originalItems = itemsWithWeights.map(iw => iw.item);\r\n    return originalItems.length > 0 ? originalItems[Math.floor(Math.random() * originalItems.length)] : null;\r\n  }\r\n\r\n  let randomValue = Math.random() * totalWeight;\r\n  for (let i = 0; i < itemsWithWeights.length; i++) {\r\n    if (randomValue < (itemsWithWeights[i].weight || 0)) {\r\n      return itemsWithWeights[i].item;\r\n    }\r\n    randomValue -= (itemsWithWeights[i].weight || 0);\r\n  }\r\n  \r\n  // Fallback in case of rounding errors or unexpected scenarios, though theoretically should be covered.\r\n  const originalItems = itemsWithWeights.map(iw => iw.item);\r\n  return originalItems.length > 0 ? originalItems[Math.floor(Math.random() * originalItems.length)] : null;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAA,YAAYA,CAACC,KAAK,CAAE,CAClC,KAAM,CAAAC,QAAQ,CAAG,CAAC,GAAGD,KAAK,CAAC,CAC3B,IAAK,GAAI,CAAAE,CAAC,CAAGD,QAAQ,CAACE,MAAM,CAAG,CAAC,CAAED,CAAC,CAAG,CAAC,CAAEA,CAAC,EAAE,CAAE,CAC5C,KAAM,CAAAE,CAAC,CAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,EAAIL,CAAC,CAAG,CAAC,CAAC,CAAC,CAC7C,CAACD,QAAQ,CAACC,CAAC,CAAC,CAAED,QAAQ,CAACG,CAAC,CAAC,CAAC,CAAG,CAACH,QAAQ,CAACG,CAAC,CAAC,CAAEH,QAAQ,CAACC,CAAC,CAAC,CAAC,CACzD,CACA,MAAO,CAAAD,QAAQ,CACjB,CAEA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAO,qBAAqBA,CAACC,gBAAgB,CAAE,CACtD,GAAI,CAACA,gBAAgB,EAAIA,gBAAgB,CAACN,MAAM,GAAK,CAAC,CAAE,CACtD,MAAO,KAAI,CACb,CAEA,KAAM,CAAAO,WAAW,CAAGD,gBAAgB,CAACE,MAAM,CAAC,CAACC,GAAG,CAAEC,KAAK,GAAKD,GAAG,EAAIC,KAAK,CAACC,MAAM,EAAI,CAAC,CAAC,CAAE,CAAC,CAAC,CACzF,GAAIJ,WAAW,EAAI,CAAC,CAAE,CACpB;AACA,KAAM,CAAAK,aAAa,CAAGN,gBAAgB,CAACO,GAAG,CAACC,EAAE,EAAIA,EAAE,CAACC,IAAI,CAAC,CACzD,MAAO,CAAAH,aAAa,CAACZ,MAAM,CAAG,CAAC,CAAGY,aAAa,CAACV,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAGQ,aAAa,CAACZ,MAAM,CAAC,CAAC,CAAG,IAAI,CAC1G,CAEA,GAAI,CAAAgB,WAAW,CAAGd,IAAI,CAACE,MAAM,CAAC,CAAC,CAAGG,WAAW,CAC7C,IAAK,GAAI,CAAAR,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGO,gBAAgB,CAACN,MAAM,CAAED,CAAC,EAAE,CAAE,CAChD,GAAIiB,WAAW,EAAIV,gBAAgB,CAACP,CAAC,CAAC,CAACY,MAAM,EAAI,CAAC,CAAC,CAAE,CACnD,MAAO,CAAAL,gBAAgB,CAACP,CAAC,CAAC,CAACgB,IAAI,CACjC,CACAC,WAAW,EAAKV,gBAAgB,CAACP,CAAC,CAAC,CAACY,MAAM,EAAI,CAAE,CAClD,CAEA;AACA,KAAM,CAAAC,aAAa,CAAGN,gBAAgB,CAACO,GAAG,CAACC,EAAE,EAAIA,EAAE,CAACC,IAAI,CAAC,CACzD,MAAO,CAAAH,aAAa,CAACZ,MAAM,CAAG,CAAC,CAAGY,aAAa,CAACV,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAGQ,aAAa,CAACZ,MAAM,CAAC,CAAC,CAAG,IAAI,CAC1G","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}